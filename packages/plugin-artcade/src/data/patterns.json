[
    {
        "id": "cursor-follow-1",
        "pattern_name": "Cursor Following",
        "type": "interaction",
        "effectiveness_score": 0.85,
        "usage_count": 1,
        "content": {
            "context": "Smooth cursor following with easing",
            "metadata": {
                "visual_type": "cursor_tracking",
                "interaction_type": "mouse_follow",
                "animation_duration": "0.3s"
            },
            "implementation": {
                "html": [
                    "<div id='gameArea'>",
                    "  <div class='trail'></div>",
                    "</div>"
                ],
                "eventHandlers": [
                    "document.addEventListener('mousemove', e => {",
                    "  const trail = document.createElement('div');",
                    "  trail.className = 'trail';",
                    "  trail.style.left = e.clientX + 'px';",
                    "  trail.style.top = e.clientY + 'px';",
                    "  gameArea.appendChild(trail);",
                    "  setTimeout(() => trail.remove(), 1000);",
                    "  score += 1;",
                    "  document.getElementById('score').textContent = score;",
                    "});"
                ],
                "css": [
                    ".trail {",
                    "  position: absolute;",
                    "  width: 32px;",
                    "  height: 32px;",
                    "  background: #0f0;",
                    "  border-radius: 50%;",
                    "  transition: all 0.3s;",
                    "  pointer-events: none;",
                    "  opacity: 0.8;",
                    "}",
                    "",
                    ".trail:hover {",
                    "  transform: scale(1.2);",
                    "  opacity: 1;",
                    "}"
                ],
                "animations": [
                    "@keyframes fadeOut {",
                    "  from { opacity: 0.8; }",
                    "  to { opacity: 0; }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "physics-movement-1",
        "pattern_name": "Physics-Based Movement",
        "type": "mechanics",
        "effectiveness_score": 0.9,
        "usage_count": 2,
        "content": {
            "context": "Momentum-based movement with friction and acceleration",
            "metadata": {
                "mechanics_type": "vehicle_physics",
                "interaction_type": "keyboard_input",
                "properties": ["friction", "acceleration", "turning"]
            },
            "implementation": {
                "constants": [
                    "const friction = 0.93;",
                    "const turnSpeed = 4;",
                    "const playerSpeed = 6;"
                ],
                "state": [
                    "let playerX = 2000;",
                    "let playerY = 2000;",
                    "let playerAngle = 0;",
                    "let playerVelX = 0;",
                    "let playerVelY = 0;"
                ],
                "controls": {
                    "setup": [
                        "const keys = {",
                        "  ArrowLeft: false,",
                        "  ArrowRight: false,",
                        "  ArrowUp: false,",
                        "  ArrowDown: false",
                        "};"
                    ],
                    "eventHandlers": [
                        "document.addEventListener('keydown', (e) => {",
                        "  if (keys.hasOwnProperty(e.key)) {",
                        "    keys[e.key] = true;",
                        "  }",
                        "});",
                        "",
                        "document.addEventListener('keyup', (e) => {",
                        "  if (keys.hasOwnProperty(e.key)) {",
                        "    keys[e.key] = false;",
                        "  }",
                        "});"
                    ]
                },
                "updateLogic": [
                    "function updatePlayer() {",
                    "  if (!gameIsOver) {",
                    "    if (keys.ArrowLeft) playerAngle -= turnSpeed;",
                    "    if (keys.ArrowRight) playerAngle += turnSpeed;",
                    "    ",
                    "    const angleRad = playerAngle * Math.PI / 180;",
                    "    ",
                    "    if (keys.ArrowUp) {",
                    "      playerVelX += Math.cos(angleRad) * 0.4;",
                    "      playerVelY += Math.sin(angleRad) * 0.4;",
                    "    }",
                    "    if (keys.ArrowDown) {",
                    "      playerVelX -= Math.cos(angleRad) * 0.2;",
                    "      playerVelY -= Math.sin(angleRad) * 0.2;",
                    "    }",
                    "    ",
                    "    playerVelX *= friction;",
                    "    playerVelY *= friction;",
                    "    ",
                    "    playerX += playerVelX;",
                    "    playerY += playerVelY;",
                    "    ",
                    "    // Update player position and rotation",
                    "    player.style.left = (playerX - 15) + 'px';",
                    "    player.style.top = (playerY - 7.5) + 'px';",
                    "    player.style.transform = `rotate(${playerAngle}deg)`;",
                    "  }",
                    "}"
                ],
                "css": [
                    ".player {",
                    "  position: absolute;",
                    "  width: 30px;",
                    "  height: 15px;",
                    "  background: var(--car-color, #0f0);",
                    "  border-radius: 3px;",
                    "  pointer-events: none;",
                    "  transform-origin: center;",
                    "  transition: transform 0.2s ease-out;",
                    "}"
                ]
            }
        }
    },
    {
        "id": "pursuit-ai-1",
        "pattern_name": "Dynamic Pursuit AI",
        "type": "ai",
        "effectiveness_score": 0.85,
        "usage_count": 1,
        "content": {
            "context": "AI agents that pursue with varied movement patterns",
            "metadata": {
                "ai_type": "pursuit",
                "patterns": ["direct", "sine_wave", "circular"],
                "difficulty": "adaptive"
            },
            "implementation": {
                "helperFunctions": [
                    "function getSineWaveOffset(timestamp, amplitude = 20, frequency = 0.002) {",
                    "  return Math.sin(timestamp * frequency) * amplitude;",
                    "}",
                    "",
                    "function getCircularOffset(timestamp, radius = 30, speed = 0.003) {",
                    "  return {",
                    "    x: Math.cos(timestamp * speed) * radius,",
                    "    y: Math.sin(timestamp * speed) * radius",
                    "  };",
                    "}"
                ],
                "aiState": [
                    "const cop = {",
                    "  element: copElement,",
                    "  x: x,",
                    "  y: y,",
                    "  angle: 0,",
                    "  velocity: { x: 0, y: 0 },",
                    "  targetAngle: 0,",
                    "  movementPattern: Math.floor(Math.random() * 4), // 0: direct, 1: sine, 2: circular, 3: zigzag",
                    "  patternOffset: 0,",
                    "  lastZigzag: Date.now()",
                    "}"
                ],
                "updateLogic": [
                    "function updateCops() {",
                    "  const timestamp = Date.now();",
                    "  ",
                    "  cops.forEach(cop => {",
                    "    const dx = playerX - cop.x;",
                    "    const dy = playerY - cop.y;",
                    "    const baseAngle = Math.atan2(dy, dx);",
                    "    ",
                    "    let targetAngle = baseAngle;",
                    "    let speedMultiplier = 1;",
                    "    ",
                    "    switch(cop.movementPattern) {",
                    "      case 1: // Sine wave movement",
                    "        const sineOffset = getSineWaveOffset(timestamp);",
                    "        targetAngle += Math.sin(timestamp * 0.003) * 0.5;",
                    "        break;",
                    "        ",
                    "      case 2: // Circular pursuit",
                    "        const circularOffset = getCircularOffset(timestamp);",
                    "        cop.x += circularOffset.x * 0.1;",
                    "        cop.y += circularOffset.y * 0.1;",
                    "        targetAngle += Math.sin(timestamp * 0.002) * 0.3;",
                    "        speedMultiplier = 1.1;",
                    "        break;",
                    "        ",
                    "      case 3: // Zigzag",
                    "        if (timestamp - cop.lastZigzag > 1000) {",
                    "          cop.patternOffset = Math.random() * Math.PI/2 - Math.PI/4;",
                    "          cop.lastZigzag = timestamp;",
                    "        }",
                    "        targetAngle += cop.patternOffset;",
                    "        speedMultiplier = 1.05;",
                    "        break;",
                    "    }",
                    "    ",
                    "    const angleDiff = targetAngle - cop.angle;",
                    "    cop.angle += angleDiff * 0.1;",
                    "    ",
                    "    const targetVelX = Math.cos(targetAngle) * copSpeed * speedMultiplier;",
                    "    const targetVelY = Math.sin(targetAngle) * copSpeed * speedMultiplier;",
                    "    ",
                    "    cop.velocity.x += (targetVelX - cop.velocity.x) * 0.08;",
                    "    cop.velocity.y += (targetVelY - cop.velocity.y) * 0.08;",
                    "    ",
                    "    cop.x += cop.velocity.x;",
                    "    cop.y += cop.velocity.y;",
                    "    ",
                    "    const driftAngle = cop.angle + Math.atan2(cop.velocity.y, cop.velocity.x) * 0.5;",
                    "    ",
                    "    cop.element.style.left = cop.x + 'px';",
                    "    cop.element.style.top = cop.y + 'px';",
                    "    cop.element.style.transform = `rotate(${driftAngle * 180 / Math.PI}deg)`;",
                    "  });",
                    "}"
                ],
                "css": [
                    ".cop {",
                    "  position: absolute;",
                    "  width: 30px;",
                    "  height: 30px;",
                    "  background: #00f;",
                    "  border-radius: 5px;",
                    "  transform-origin: center;",
                    "  transition: transform 0.3s ease-out;",
                    "  animation: sirenFlash 1s infinite;",
                    "  box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "}",
                    "",
                    "@keyframes sirenFlash {",
                    "  0% {",
                    "    background: #00f;",
                    "    box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "  }",
                    "  50% {",
                    "    background: #f00;",
                    "    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);",
                    "  }",
                    "  100% {",
                    "    background: #00f;",
                    "    box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "terminal-ui-1",
        "pattern_name": "Terminal Interface",
        "type": "ui",
        "effectiveness_score": 0.8,
        "usage_count": 1,
        "content": {
            "context": "Text-based terminal interface with command responses",
            "metadata": {
                "ui_type": "terminal",
                "interaction_type": "text_input",
                "features": ["command_history", "hints"]
            }
        }
    },
    {
        "id": "visual-feedback-1",
        "pattern_name": "Dynamic Visual Feedback",
        "type": "effects",
        "effectiveness_score": 0.95,
        "usage_count": 2,
        "content": {
            "context": "Rich visual feedback for player actions and events",
            "metadata": {
                "effect_types": ["explosions", "screen_shake", "trails"],
                "animation_style": "particle_based",
                "feedback_timing": "immediate"
            }
        }
    },
    {
        "id": "powerup-system-1",
        "pattern_name": "Temporary Power-ups",
        "type": "mechanics",
        "effectiveness_score": 0.85,
        "usage_count": 2,
        "content": {
            "context": "Collectible power-ups with temporary effects",
            "metadata": {
                "spawn_type": "timed",
                "effect_duration": "temporary",
                "effect_types": ["speed_boost", "score_multiplier"]
            }
        }
    },
    {
        "id": "game-modes-1",
        "pattern_name": "Multiple Game Modes",
        "type": "structure",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Different gameplay modes with unique mechanics",
            "metadata": {
                "mode_types": ["classic", "survival", "time_trial", "stealth"],
                "progression": "unlockable",
                "difficulty_scaling": true
            }
        }
    },
    {
        "id": "synth-keyboard-1",
        "pattern_name": "Interactive Synth Keyboard",
        "type": "audio",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Interactive musical keyboard with advanced synth controls",
            "metadata": {
                "ui_type": "keyboard",
                "interaction_type": "keyboard_input",
                "features": ["waveform_control", "adsr_envelope", "effects"]
            },
            "implementation": {
                "html": [
                    "<div class='keyboard'>",
                    "  <div class='key' data-note='a'>A</div>",
                    "  <div class='key black' data-note='w'>W</div>",
                    "  <div class='key' data-note='s'>S</div>",
                    "  <!-- ... more keys ... -->",
                    "</div>",
                    "<div class='controls'>",
                    "  <div class='control'>",
                    "    <label for='waveform'>Waveform</label>",
                    "    <select id='waveform'>",
                    "      <option value='sawtooth'>Sawtooth</option>",
                    "      <option value='square'>Square</option>",
                    "      <option value='triangle'>Triangle</option>",
                    "      <option value='sine'>Sine</option>",
                    "    </select>",
                    "  </div>",
                    "  <!-- ADSR Controls -->",
                    "  <div class='control'>",
                    "    <label for='attack'>Attack</label>",
                    "    <input type='range' min='0.01' max='2' value='0.1' step='0.01' class='slider' id='attack'>",
                    "  </div>",
                    "  <!-- ... more controls ... -->",
                    "</div>"
                ],
                "css": [
                    ".keyboard {",
                    "  display: flex;",
                    "  justify-content: center;",
                    "  margin-bottom: 20px;",
                    "}",
                    ".key {",
                    "  width: 40px;",
                    "  height: 150px;",
                    "  background-color: #000922;",
                    "  border: 1px solid #3366aa;",
                    "  display: flex;",
                    "  justify-content: center;",
                    "  align-items: flex-end;",
                    "  cursor: pointer;",
                    "  transition: all 0.2s ease;",
                    "}",
                    ".key.black {",
                    "  width: 25px;",
                    "  height: 90px;",
                    "  background-color: #000011;",
                    "  margin: 0 -12px;",
                    "  z-index: 1;",
                    "}",
                    ".key:hover { background-color: #001144; }",
                    ".key.active { background-color: #002266; transform: translateY(3px); }"
                ],
                "javascript": [
                    "const audioContext = new AudioContext();",
                    "const oscillators = {};",
                    "",
                    "function playNote(note, frequency) {",
                    "  const osc = audioContext.createOscillator();",
                    "  const gainNode = audioContext.createGain();",
                    "  const filterNode = audioContext.createBiquadFilter();",
                    "",
                    "  osc.type = document.getElementById('waveform').value;",
                    "  osc.frequency.setValueAtTime(frequency, audioContext.currentTime);",
                    "",
                    "  // Apply ADSR envelope",
                    "  const attack = parseFloat(document.getElementById('attack').value);",
                    "  const decay = parseFloat(document.getElementById('decay').value);",
                    "  const sustain = parseFloat(document.getElementById('sustain').value);",
                    "",
                    "  gainNode.gain.setValueAtTime(0, audioContext.currentTime);",
                    "  gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + attack);",
                    "  gainNode.gain.linearRampToValueAtTime(sustain, audioContext.currentTime + attack + decay);",
                    "",
                    "  osc.connect(filterNode).connect(gainNode).connect(audioContext.destination);",
                    "  osc.start();",
                    "  oscillators[note] = { osc, gainNode };",
                    "}",
                    "",
                    "function stopNote(note) {",
                    "  if (oscillators[note]) {",
                    "    const release = parseFloat(document.getElementById('release').value);",
                    "    oscillators[note].gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + release);",
                    "    oscillators[note].osc.stop(audioContext.currentTime + release);",
                    "    delete oscillators[note];",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "shader-customization-1",
        "pattern_name": "Interactive Shader Customization",
        "type": "graphics",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Real-time customizable WebGL shader with interactive controls",
            "metadata": {
                "graphics_type": "webgl_shader",
                "interaction_type": "parameter_controls",
                "features": [
                    "color_palette",
                    "animation_speed",
                    "mirror_effect"
                ]
            },
            "implementation": {
                "html": [
                    "<canvas id='shaderCanvas'></canvas>",
                    "<div id='customizeMenu'>",
                    "  <label for='speed'>Animation Speed:</label>",
                    "  <input type='range' id='speed' min='0' max='2' step='0.1' value='1'>",
                    "  <label for='iterations'>Iterations:</label>",
                    "  <input type='range' id='iterations' min='1' max='10' step='1' value='4'>",
                    "  <!-- ... more controls ... -->",
                    "  <div class='color-picker'>",
                    "    <input type='color' id='color1' value='#808080'>",
                    "    <label for='color1'>Color 1</label>",
                    "  </div>",
                    "</div>"
                ],
                "shaders": {
                    "vertex": [
                        "attribute vec4 aVertexPosition;",
                        "void main() {",
                        "  gl_Position = aVertexPosition;",
                        "}"
                    ],
                    "fragment": [
                        "precision highp float;",
                        "uniform vec2 uResolution;",
                        "uniform float uTime;",
                        "uniform float uIterations;",
                        "uniform float uColorShift;",
                        "uniform float uZoom;",
                        "uniform vec3 uColor1;",
                        "uniform vec3 uColor2;",
                        "uniform vec3 uColor3;",
                        "uniform vec3 uColor4;",
                        "uniform float uMirrors;",
                        "",
                        "vec3 palette(float t) {",
                        "  vec3 a = uColor1;",
                        "  vec3 b = uColor2;",
                        "  vec3 c = uColor3;",
                        "  vec3 d = uColor4;",
                        "  return a + b*cos(6.28318*(c*t+d));",
                        "}",
                        "",
                        "void main() {",
                        "  vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;",
                        "  uv *= uZoom;",
                        "  ",
                        "  // Apply mirror effect",
                        "  float angle = atan(uv.y, uv.x);",
                        "  float radius = length(uv);",
                        "  float sector = 6.28318 / uMirrors;",
                        "  angle = mod(angle, sector);",
                        "  if (mod(floor(atan(uv.y, uv.x) / sector), 2.0) == 1.0) {",
                        "    angle = sector - angle;",
                        "  }",
                        "  uv = vec2(cos(angle), sin(angle)) * radius;",
                        "  ",
                        "  vec3 finalColor = vec3(0.0);",
                        "  // ... shader computation ...",
                        "  gl_FragColor = vec4(finalColor, 1.0);",
                        "}"
                    ]
                },
                "javascript": [
                    "function initShaderProgram(gl, vsSource, fsSource) {",
                    "  const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);",
                    "  const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);",
                    "  const program = gl.createProgram();",
                    "  gl.attachShader(program, vertexShader);",
                    "  gl.attachShader(program, fragmentShader);",
                    "  gl.linkProgram(program);",
                    "  return program;",
                    "}",
                    "",
                    "function updateUniforms(gl, program) {",
                    "  gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);",
                    "  gl.uniform1f(timeUniformLocation, time * speed);",
                    "  gl.uniform1f(iterationsUniformLocation, iterations);",
                    "  gl.uniform1f(colorShiftUniformLocation, colorShift);",
                    "  gl.uniform1f(zoomUniformLocation, zoom);",
                    "  gl.uniform1f(mirrorsUniformLocation, mirrors);",
                    "  gl.uniform3fv(color1UniformLocation, color1);",
                    "  // ... update other uniforms ...",
                    "}"
                ]
            }
        }
    },
    {
        "id": "typing-game-1",
        "pattern_name": "Fast-Paced Typing Game",
        "type": "mechanics",
        "effectiveness_score": 0.75,
        "usage_count": 1,
        "content": {
            "context": "Fast-paced typing game with word generation and instant feedback",
            "metadata": {
                "mechanics_type": "typing_game",
                "interaction_type": "keyboard_input",
                "strengths": [
                    "immediate feedback",
                    "fast-paced gameplay",
                    "engaging core mechanic"
                ],
                "weaknesses": [
                    "lacks scoring system",
                    "poor visual feedback",
                    "disconnected visual effects"
                ]
            },
            "implementation": {
                "state": [
                    "const gameState = {",
                    "  currentWord: '',",
                    "  typedWord: '',",
                    "  wordList: ['code', 'debug', 'syntax', 'function', 'variable', 'loop'],",
                    "  score: 0,",
                    "  wordsTyped: 0,",
                    "  accuracy: 100",
                    "};"
                ],
                "core_mechanics": [
                    "function generateNewWord() {",
                    "  const randomIndex = Math.floor(Math.random() * gameState.wordList.length);",
                    "  gameState.currentWord = gameState.wordList[randomIndex];",
                    "  gameState.typedWord = '';",
                    "  updateWordDisplay();",
                    "}",
                    "",
                    "function handleKeyPress(event) {",
                    "  const key = event.key.toLowerCase();",
                    "  ",
                    "  if (key === gameState.currentWord[gameState.typedWord.length]) {",
                    "    gameState.typedWord += key;",
                    "    updateWordDisplay();",
                    "    ",
                    "    if (gameState.typedWord === gameState.currentWord) {",
                    "      gameState.score += gameState.currentWord.length * 10;",
                    "      gameState.wordsTyped++;",
                    "      updateScore();",
                    "      generateNewWord();",
                    "    }",
                    "  } else {",
                    "    // Wrong key pressed",
                    "    gameState.accuracy = Math.max(0, gameState.accuracy - 1);",
                    "    updateAccuracy();",
                    "    shakeWord(); // Visual feedback for mistakes",
                    "  }",
                    "}"
                ],
                "display": [
                    "function updateWordDisplay() {",
                    "  const wordElement = document.getElementById('current-word');",
                    "  const typed = gameState.typedWord;",
                    "  const remaining = gameState.currentWord.slice(typed.length);",
                    "  ",
                    "  wordElement.innerHTML = `",
                    "    <span class='typed'>${typed}</span>",
                    "    <span class='remaining'>${remaining}</span>",
                    "  `;",
                    "}",
                    "",
                    "function updateScore() {",
                    "  document.getElementById('score').textContent = gameState.score;",
                    "  document.getElementById('words-typed').textContent = gameState.wordsTyped;",
                    "  document.getElementById('accuracy').textContent = gameState.accuracy + '%';",
                    "}"
                ],
                "css": [
                    ".game-container {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  align-items: center;",
                    "  justify-content: center;",
                    "  min-height: 100vh;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "}",
                    "",
                    "#current-word {",
                    "  font-size: 2.5rem;",
                    "  font-family: monospace;",
                    "  margin: 2rem 0;",
                    "}",
                    "",
                    ".typed {",
                    "  color: #4CAF50;",
                    "  text-decoration: underline;",
                    "}",
                    "",
                    ".remaining {",
                    "  color: #fff;",
                    "}",
                    "",
                    ".shake {",
                    "  animation: shake 0.2s ease-in-out;",
                    "}",
                    "",
                    "@keyframes shake {",
                    "  0%, 100% { transform: translateX(0); }",
                    "  25% { transform: translateX(-5px); }",
                    "  75% { transform: translateX(5px); }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "cursor-sound-1",
        "pattern_name": "Cursor Sound Trail",
        "type": "interaction",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Interactive cursor trail with synchronized audio feedback",
            "metadata": {
                "visual_type": "cursor_trail",
                "interaction_type": "mouse_move",
                "features": [
                    "audio_feedback",
                    "visual_trail",
                    "position_based_sound"
                ]
            },
            "implementation": {
                "html": [
                    "<canvas id='soundCanvas'></canvas>",
                    "<div id='cursor-trail'></div>"
                ],
                "audioSetup": [
                    "const audioCtx = new AudioContext();",
                    "const oscillator = audioCtx.createOscillator();",
                    "const gainNode = audioCtx.createGain();",
                    "",
                    "oscillator.connect(gainNode);",
                    "gainNode.connect(audioCtx.destination);",
                    "oscillator.start();"
                ],
                "eventHandlers": [
                    "document.addEventListener('mousemove', e => {",
                    "  // Update audio parameters based on cursor position",
                    "  const x = e.clientX / window.innerWidth;",
                    "  const y = e.clientY / window.innerHeight;",
                    "  ",
                    "  // Map X position to frequency (pitch)",
                    "  const minFreq = 220; // A3",
                    "  const maxFreq = 880; // A5",
                    "  const frequency = minFreq + (x * (maxFreq - minFreq));",
                    "  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);",
                    "  ",
                    "  // Map Y position to volume",
                    "  const volume = 1 - (y * 0.8); // Higher = quieter",
                    "  gainNode.gain.setValueAtTime(volume * 0.5, audioCtx.currentTime);",
                    "  ",
                    "  // Create and animate trail particle",
                    "  createTrailParticle(e.clientX, e.clientY, frequency);",
                    "});"
                ],
                "trailEffects": [
                    "function createTrailParticle(x, y, freq) {",
                    "  const particle = document.createElement('div');",
                    "  particle.className = 'trail-particle';",
                    "  ",
                    "  // Map frequency to hue for color",
                    "  const hue = ((freq - 220) / (880 - 220)) * 360;",
                    "  particle.style.background = `hsla(${hue}, 80%, 60%, 0.8)`;",
                    "  ",
                    "  particle.style.left = x + 'px';",
                    "  particle.style.top = y + 'px';",
                    "  ",
                    "  document.body.appendChild(particle);",
                    "  ",
                    "  // Animate and remove",
                    "  requestAnimationFrame(() => {",
                    "    particle.style.transform = 'scale(0)';",
                    "    particle.style.opacity = '0';",
                    "  });",
                    "  ",
                    "  setTimeout(() => particle.remove(), 1000);",
                    "}"
                ],
                "css": [
                    "#cursor-trail {",
                    "  position: fixed;",
                    "  top: 0;",
                    "  left: 0;",
                    "  pointer-events: none;",
                    "  z-index: 9999;",
                    "}",
                    "",
                    ".trail-particle {",
                    "  position: absolute;",
                    "  width: 20px;",
                    "  height: 20px;",
                    "  border-radius: 50%;",
                    "  pointer-events: none;",
                    "  transform-origin: center;",
                    "  transform: scale(1);",
                    "  opacity: 0.8;",
                    "  transition: all 1s cubic-bezier(0.23, 1, 0.32, 1);",
                    "  mix-blend-mode: screen;",
                    "  filter: blur(2px);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "orbital-chaos-1",
        "pattern_name": "Orbital Chaos System",
        "type": "visual",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Visually striking orbital system with dynamic particle movement",
            "metadata": {
                "visual_type": "orbital_system",
                "interaction_type": "autonomous",
                "features": [
                    "central_attractor",
                    "multiple_orbits",
                    "particle_effects",
                    "dynamic_trails"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.createElement('canvas');",
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "// Central attractor",
                    "const center = {",
                    "  x: window.innerWidth / 2,",
                    "  y: window.innerHeight / 2,",
                    "  radius: 30,",
                    "  glow: 50",
                    "};",
                    "",
                    "// Orbital bodies",
                    "const orbiters = Array.from({ length: 8 }, (_, i) => ({",
                    "  angle: (Math.PI * 2 * i) / 8,",
                    "  radius: 15,",
                    "  orbitRadius: 150 + (i * 30),",
                    "  speed: 0.001 + (i * 0.0005),",
                    "  trail: []",
                    "}));"
                ],
                "render": [
                    "function render(timestamp) {",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';",
                    "  ctx.fillRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Render central attractor",
                    "  const gradient = ctx.createRadialGradient(",
                    "    center.x, center.y, 0,",
                    "    center.x, center.y, center.glow",
                    "  );",
                    "  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');",
                    "  gradient.addColorStop(0.4, 'rgba(64, 190, 255, 0.8)');",
                    "  gradient.addColorStop(1, 'rgba(32, 90, 255, 0)');",
                    "  ",
                    "  ctx.beginPath();",
                    "  ctx.arc(center.x, center.y, center.radius, 0, Math.PI * 2);",
                    "  ctx.fillStyle = gradient;",
                    "  ctx.fill();",
                    "",
                    "  // Update and render orbiters",
                    "  orbiters.forEach((orbiter, i) => {",
                    "    orbiter.angle += orbiter.speed;",
                    "    ",
                    "    const x = center.x + Math.cos(orbiter.angle) * orbiter.orbitRadius;",
                    "    const y = center.y + Math.sin(orbiter.angle) * orbiter.orbitRadius;",
                    "    ",
                    "    // Update trail",
                    "    orbiter.trail.unshift({ x, y, alpha: 1 });",
                    "    if (orbiter.trail.length > 50) orbiter.trail.pop();",
                    "    ",
                    "    // Render trail",
                    "    orbiter.trail.forEach((point, j) => {",
                    "      point.alpha *= 0.95;",
                    "      ctx.beginPath();",
                    "      ctx.arc(point.x, point.y, orbiter.radius * (1 - j/50), 0, Math.PI * 2);",
                    "      ctx.fillStyle = `hsla(${(i * 45) + 200}, 100%, 60%, ${point.alpha})`;",
                    "      ctx.fill();",
                    "    });",
                    "    ",
                    "    // Render orbiter",
                    "    const orbGradient = ctx.createRadialGradient(",
                    "      x, y, 0,",
                    "      x, y, orbiter.radius * 2",
                    "    );",
                    "    orbGradient.addColorStop(0, `hsla(${(i * 45) + 200}, 100%, 70%, 1)`);",
                    "    orbGradient.addColorStop(0.5, `hsla(${(i * 45) + 200}, 100%, 50%, 0.5)`);",
                    "    orbGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');",
                    "    ",
                    "    ctx.beginPath();",
                    "    ctx.arc(x, y, orbiter.radius, 0, Math.PI * 2);",
                    "    ctx.fillStyle = orbGradient;",
                    "    ctx.fill();",
                    "  });",
                    "",
                    "  requestAnimationFrame(render);",
                    "}"
                ],
                "css": [
                    "canvas {",
                    "  position: fixed;",
                    "  top: 0;",
                    "  left: 0;",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "  background: #000;",
                    "}"
                ],
                "initialization": [
                    "canvas.width = window.innerWidth;",
                    "canvas.height = window.innerHeight;",
                    "document.body.appendChild(canvas);",
                    "requestAnimationFrame(render);"
                ]
            }
        }
    },
    {
        "id": "y2k-guestbook-1",
        "pattern_name": "Y2K Floating Guestbook",
        "type": "interactive",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Retro Y2K-style floating message board with nostalgic internet aesthetics",
            "metadata": {
                "visual_type": "retro_floating",
                "interaction_type": "message_input",
                "features": [
                    "floating_messages",
                    "y2k_aesthetics",
                    "persistent_messages",
                    "community_interaction"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='guestbook-container'>",
                    "  <div class='message-input'>",
                    "    <input type='text' id='message' placeholder='Leave your message...'>",
                    "    <button onclick='addMessage()'>✨ Post ✨</button>",
                    "  </div>",
                    "  <div id='message-space' class='message-space'></div>",
                    "</div>"
                ],
                "css": [
                    ".guestbook-container {",
                    "  background: linear-gradient(45deg, #000022, #000044);",
                    "  min-height: 100vh;",
                    "  overflow: hidden;",
                    "  position: relative;",
                    "}",
                    "",
                    ".message-input {",
                    "  position: fixed;",
                    "  bottom: 20px;",
                    "  left: 50%;",
                    "  transform: translateX(-50%);",
                    "  z-index: 1000;",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  padding: 15px;",
                    "  border-radius: 25px;",
                    "  border: 2px solid rgba(255, 255, 255, 0.2);",
                    "  backdrop-filter: blur(10px);",
                    "}",
                    "",
                    "input {",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  border: 1px solid rgba(255, 255, 255, 0.3);",
                    "  color: #fff;",
                    "  padding: 8px 15px;",
                    "  border-radius: 20px;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  margin-right: 10px;",
                    "}",
                    "",
                    "button {",
                    "  background: linear-gradient(45deg, #ff00ff, #00ffff);",
                    "  border: none;",
                    "  color: #fff;",
                    "  padding: 8px 20px;",
                    "  border-radius: 20px;",
                    "  cursor: pointer;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);",
                    "}",
                    "",
                    ".floating-message {",
                    "  position: absolute;",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  padding: 15px;",
                    "  border-radius: 15px;",
                    "  border: 2px solid rgba(255, 255, 255, 0.2);",
                    "  backdrop-filter: blur(5px);",
                    "  color: #fff;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);",
                    "  animation: float 20s linear infinite;",
                    "  white-space: nowrap;",
                    "  cursor: pointer;",
                    "  transition: transform 0.3s, filter 0.3s;",
                    "}",
                    "",
                    ".floating-message:hover {",
                    "  transform: scale(1.1);",
                    "  filter: brightness(1.2);",
                    "}",
                    "",
                    "@keyframes float {",
                    "  0% { transform: translate(100vw, random(100vh)); }",
                    "  100% { transform: translate(-100%, random(100vh)); }",
                    "}"
                ],
                "javascript": [
                    "const messages = [];",
                    "",
                    "function addMessage() {",
                    "  const input = document.getElementById('message');",
                    "  const text = input.value.trim();",
                    "  if (!text) return;",
                    "",
                    "  const message = {",
                    "    text,",
                    "    timestamp: Date.now(),",
                    "    color: `hsl(${Math.random() * 360}, 80%, 75%)`,",
                    "    speed: 10 + Math.random() * 10,",
                    "    verticalPos: Math.random() * 80 + 10",
                    "  };",
                    "",
                    "  messages.push(message);",
                    "  createFloatingMessage(message);",
                    "  input.value = '';",
                    "  ",
                    "  // Store in localStorage",
                    "  localStorage.setItem('guestbookMessages', JSON.stringify(messages));",
                    "}",
                    "",
                    "function createFloatingMessage(message) {",
                    "  const element = document.createElement('div');",
                    "  element.className = 'floating-message';",
                    "  element.textContent = message.text;",
                    "  element.style.top = `${message.verticalPos}vh`;",
                    "  element.style.color = message.color;",
                    "  element.style.animationDuration = `${message.speed}s`;",
                    "",
                    "  const messageSpace = document.getElementById('message-space');",
                    "  messageSpace.appendChild(element);",
                    "",
                    "  element.addEventListener('animationend', () => {",
                    "    element.remove();",
                    "    // Recreate the message for continuous flow",
                    "    setTimeout(() => createFloatingMessage(message), Math.random() * 5000);",
                    "  });",
                    "}",
                    "",
                    "// Load saved messages",
                    "window.addEventListener('load', () => {",
                    "  const saved = localStorage.getItem('guestbookMessages');",
                    "  if (saved) {",
                    "    const savedMessages = JSON.parse(saved);",
                    "    savedMessages.forEach(msg => {",
                    "      messages.push(msg);",
                    "      createFloatingMessage(msg);",
                    "    });",
                    "  }",
                    "});"
                ]
            }
        }
    },
    {
        "id": "harmonic-click-1",
        "pattern_name": "Harmonic Click Interaction",
        "type": "audio_visual",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Click-based musical interaction with spatial sound mapping and visual collision effects",
            "metadata": {
                "audio_type": "spatial_harmonic",
                "interaction_type": "click",
                "features": [
                    "position_based_pitch",
                    "collision_harmonics",
                    "visual_feedback",
                    "musical_scale"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.getElementById('canvas');",
                    "const ctx = canvas.getContext('2d');",
                    "const notes = [];",
                    "const palette = ['#ff6384', '#36a2eb', '#ffce56', '#9966ff', '#4bc0c0'];",
                    "",
                    "const audioCtx = new (window.AudioContext || window.webkitAudioContext)();",
                    "const masterGain = audioCtx.createGain();",
                    "masterGain.connect(audioCtx.destination);",
                    "masterGain.gain.value = 0.5;"
                ],
                "audioFunctions": [
                    "function playNote(freq) {",
                    "  const osc = audioCtx.createOscillator();",
                    "  osc.type = 'sine';",
                    "  osc.frequency.value = freq;",
                    "",
                    "  const gain = audioCtx.createGain();",
                    "  gain.connect(masterGain);",
                    "  osc.connect(gain);",
                    "",
                    "  // Envelope for smooth attack/release",
                    "  gain.gain.setValueAtTime(0, audioCtx.currentTime);",
                    "  gain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.01);",
                    "  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);",
                    "",
                    "  osc.start();",
                    "  osc.stop(audioCtx.currentTime + 0.3);",
                    "  return osc;",
                    "}"
                ],
                "noteManagement": [
                    "function createNote(x, y, freq) {",
                    "  const note = {",
                    "    x,",
                    "    y,",
                    "    vx: Math.random() * 4 - 2,",
                    "    vy: Math.random() * 4 - 2,",
                    "    r: 10,",
                    "    freq,",
                    "    osc: playNote(freq),",
                    "    color: palette[Math.floor(Math.random() * palette.length)]",
                    "  };",
                    "  notes.push(note);",
                    "}",
                    "",
                    "function moveNote(note) {",
                    "  note.x += note.vx;",
                    "  note.y += note.vy;",
                    "  ",
                    "  // Bounce off walls",
                    "  if (note.x < note.r || note.x > width - note.r) note.vx *= -1;",
                    "  if (note.y < note.r || note.y > height - note.r) note.vy *= -1;",
                    "}"
                ],
                "collisionSystem": [
                    "function detectCollisions() {",
                    "  for (let i = 0; i < notes.length; i++) {",
                    "    for (let j = i + 1; j < notes.length; j++) {",
                    "      const dx = notes[i].x - notes[j].x;",
                    "      const dy = notes[i].y - notes[j].y;",
                    "      const dist = Math.sqrt(dx * dx + dy * dy);",
                    "",
                    "      if (dist < notes[i].r + notes[j].r) {",
                    "        // Calculate harmonic frequency",
                    "        const freq1 = notes[i].freq;",
                    "        const freq2 = notes[j].freq;",
                    "        const ratio = freq2 / freq1;",
                    "        const newFreq = freq1 * Math.pow(2, Math.round(Math.log2(ratio)) / 12);",
                    "",
                    "        // Play new harmonic note",
                    "        if (!oscillators[newFreq]) {",
                    "          oscillators[newFreq] = playNote(newFreq);",
                    "        }",
                    "",
                    "        // Update colliding notes",
                    "        notes[i].osc.stop();",
                    "        notes[j].osc.stop();",
                    "        notes[i].freq = notes[j].freq = newFreq;",
                    "        notes[i].osc = notes[j].osc = oscillators[newFreq];",
                    "        notes[i].color = notes[j].color = palette[Object.keys(oscillators).length % palette.length];",
                    "      }",
                    "    }",
                    "  }",
                    "}"
                ],
                "rendering": [
                    "function drawNote(note) {",
                    "  ctx.beginPath();",
                    "  ctx.arc(note.x, note.y, note.r, 0, 2 * Math.PI);",
                    "  ctx.fillStyle = note.color;",
                    "  ctx.fill();",
                    "}",
                    "",
                    "function drawBackground() {",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';",
                    "  ctx.fillRect(0, 0, width, height);",
                    "}"
                ],
                "eventHandlers": [
                    "canvas.addEventListener('click', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = e.clientX - rect.left;",
                    "  const y = e.clientY - rect.top;",
                    "",
                    "  // Map click position to musical frequency",
                    "  // A4 (440Hz) ± 6 semitones based on position",
                    "  const freq = 440 * Math.pow(2, (Math.random() * 2 - 1) * 6 / 12);",
                    "  createNote(x, y, freq);",
                    "});"
                ],
                "mainLoop": [
                    "function render() {",
                    "  ctx.clearRect(0, 0, width, height);",
                    "  drawBackground();",
                    "",
                    "  for (const note of notes) {",
                    "    drawNote(note);",
                    "    moveNote(note);",
                    "  }",
                    "",
                    "  detectCollisions();",
                    "  requestAnimationFrame(render);",
                    "}"
                ]
            }
        }
    }
]
