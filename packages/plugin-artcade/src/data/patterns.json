[
    {
        "id": "cursor-follow-1",
        "pattern_name": "Cursor Following",
        "type": "interaction",
        "effectiveness_score": 0.85,
        "usage_count": 1,
        "content": {
            "context": "Smooth cursor following with easing",
            "metadata": {
                "visual_type": "cursor_tracking",
                "interaction_type": "mouse_follow",
                "animation_duration": "0.3s"
            },
            "implementation": {
                "html": [
                    "<div id='gameArea'>",
                    "  <div class='trail'></div>",
                    "</div>"
                ],
                "eventHandlers": [
                    "document.addEventListener('mousemove', e => {",
                    "  const trail = document.createElement('div');",
                    "  trail.className = 'trail';",
                    "  trail.style.left = e.clientX + 'px';",
                    "  trail.style.top = e.clientY + 'px';",
                    "  gameArea.appendChild(trail);",
                    "  setTimeout(() => trail.remove(), 1000);",
                    "  score += 1;",
                    "  document.getElementById('score').textContent = score;",
                    "});"
                ],
                "css": [
                    ".trail {",
                    "  position: absolute;",
                    "  width: 32px;",
                    "  height: 32px;",
                    "  background: #0f0;",
                    "  border-radius: 50%;",
                    "  transition: all 0.3s;",
                    "  pointer-events: none;",
                    "  opacity: 0.8;",
                    "}",
                    "",
                    ".trail:hover {",
                    "  transform: scale(1.2);",
                    "  opacity: 1;",
                    "}"
                ],
                "animations": [
                    "@keyframes fadeOut {",
                    "  from { opacity: 0.8; }",
                    "  to { opacity: 0; }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "physics-movement-1",
        "pattern_name": "Physics-Based Movement",
        "type": "mechanics",
        "effectiveness_score": 0.9,
        "usage_count": 2,
        "content": {
            "context": "Momentum-based movement with friction and acceleration",
            "metadata": {
                "mechanics_type": "vehicle_physics",
                "interaction_type": "keyboard_input",
                "properties": ["friction", "acceleration", "turning"]
            },
            "implementation": {
                "constants": [
                    "const friction = 0.93;",
                    "const turnSpeed = 4;",
                    "const playerSpeed = 6;"
                ],
                "state": [
                    "let playerX = 2000;",
                    "let playerY = 2000;",
                    "let playerAngle = 0;",
                    "let playerVelX = 0;",
                    "let playerVelY = 0;"
                ],
                "controls": {
                    "setup": [
                        "const keys = {",
                        "  ArrowLeft: false,",
                        "  ArrowRight: false,",
                        "  ArrowUp: false,",
                        "  ArrowDown: false",
                        "};"
                    ],
                    "eventHandlers": [
                        "document.addEventListener('keydown', (e) => {",
                        "  if (keys.hasOwnProperty(e.key)) {",
                        "    keys[e.key] = true;",
                        "  }",
                        "});",
                        "",
                        "document.addEventListener('keyup', (e) => {",
                        "  if (keys.hasOwnProperty(e.key)) {",
                        "    keys[e.key] = false;",
                        "  }",
                        "});"
                    ]
                },
                "updateLogic": [
                    "function updatePlayer() {",
                    "  if (!gameIsOver) {",
                    "    if (keys.ArrowLeft) playerAngle -= turnSpeed;",
                    "    if (keys.ArrowRight) playerAngle += turnSpeed;",
                    "    ",
                    "    const angleRad = playerAngle * Math.PI / 180;",
                    "    ",
                    "    if (keys.ArrowUp) {",
                    "      playerVelX += Math.cos(angleRad) * 0.4;",
                    "      playerVelY += Math.sin(angleRad) * 0.4;",
                    "    }",
                    "    if (keys.ArrowDown) {",
                    "      playerVelX -= Math.cos(angleRad) * 0.2;",
                    "      playerVelY -= Math.sin(angleRad) * 0.2;",
                    "    }",
                    "    ",
                    "    playerVelX *= friction;",
                    "    playerVelY *= friction;",
                    "    ",
                    "    playerX += playerVelX;",
                    "    playerY += playerVelY;",
                    "    ",
                    "    // Update player position and rotation",
                    "    player.style.left = (playerX - 15) + 'px';",
                    "    player.style.top = (playerY - 7.5) + 'px';",
                    "    player.style.transform = `rotate(${playerAngle}deg)`;",
                    "  }",
                    "}"
                ],
                "css": [
                    ".player {",
                    "  position: absolute;",
                    "  width: 30px;",
                    "  height: 15px;",
                    "  background: var(--car-color, #0f0);",
                    "  border-radius: 3px;",
                    "  pointer-events: none;",
                    "  transform-origin: center;",
                    "  transition: transform 0.2s ease-out;",
                    "}"
                ]
            }
        }
    },
    {
        "id": "pursuit-ai-1",
        "pattern_name": "Dynamic Pursuit AI",
        "type": "ai",
        "effectiveness_score": 0.85,
        "usage_count": 1,
        "content": {
            "context": "AI agents that pursue with varied movement patterns",
            "metadata": {
                "ai_type": "pursuit",
                "patterns": ["direct", "sine_wave", "circular"],
                "difficulty": "adaptive"
            },
            "implementation": {
                "helperFunctions": [
                    "function getSineWaveOffset(timestamp, amplitude = 20, frequency = 0.002) {",
                    "  return Math.sin(timestamp * frequency) * amplitude;",
                    "}",
                    "",
                    "function getCircularOffset(timestamp, radius = 30, speed = 0.003) {",
                    "  return {",
                    "    x: Math.cos(timestamp * speed) * radius,",
                    "    y: Math.sin(timestamp * speed) * radius",
                    "  };",
                    "}"
                ],
                "aiState": [
                    "const cop = {",
                    "  element: copElement,",
                    "  x: x,",
                    "  y: y,",
                    "  angle: 0,",
                    "  velocity: { x: 0, y: 0 },",
                    "  targetAngle: 0,",
                    "  movementPattern: Math.floor(Math.random() * 4), // 0: direct, 1: sine, 2: circular, 3: zigzag",
                    "  patternOffset: 0,",
                    "  lastZigzag: Date.now()",
                    "}"
                ],
                "updateLogic": [
                    "function updateCops() {",
                    "  const timestamp = Date.now();",
                    "  ",
                    "  cops.forEach(cop => {",
                    "    const dx = playerX - cop.x;",
                    "    const dy = playerY - cop.y;",
                    "    const baseAngle = Math.atan2(dy, dx);",
                    "    ",
                    "    let targetAngle = baseAngle;",
                    "    let speedMultiplier = 1;",
                    "    ",
                    "    switch(cop.movementPattern) {",
                    "      case 1: // Sine wave movement",
                    "        const sineOffset = getSineWaveOffset(timestamp);",
                    "        targetAngle += Math.sin(timestamp * 0.003) * 0.5;",
                    "        break;",
                    "        ",
                    "      case 2: // Circular pursuit",
                    "        const circularOffset = getCircularOffset(timestamp);",
                    "        cop.x += circularOffset.x * 0.1;",
                    "        cop.y += circularOffset.y * 0.1;",
                    "        targetAngle += Math.sin(timestamp * 0.002) * 0.3;",
                    "        speedMultiplier = 1.1;",
                    "        break;",
                    "        ",
                    "      case 3: // Zigzag",
                    "        if (timestamp - cop.lastZigzag > 1000) {",
                    "          cop.patternOffset = Math.random() * Math.PI/2 - Math.PI/4;",
                    "          cop.lastZigzag = timestamp;",
                    "        }",
                    "        targetAngle += cop.patternOffset;",
                    "        speedMultiplier = 1.05;",
                    "        break;",
                    "    }",
                    "    ",
                    "    const angleDiff = targetAngle - cop.angle;",
                    "    cop.angle += angleDiff * 0.1;",
                    "    ",
                    "    const targetVelX = Math.cos(targetAngle) * copSpeed * speedMultiplier;",
                    "    const targetVelY = Math.sin(targetAngle) * copSpeed * speedMultiplier;",
                    "    ",
                    "    cop.velocity.x += (targetVelX - cop.velocity.x) * 0.08;",
                    "    cop.velocity.y += (targetVelY - cop.velocity.y) * 0.08;",
                    "    ",
                    "    cop.x += cop.velocity.x;",
                    "    cop.y += cop.velocity.y;",
                    "    ",
                    "    const driftAngle = cop.angle + Math.atan2(cop.velocity.y, cop.velocity.x) * 0.5;",
                    "    ",
                    "    cop.element.style.left = cop.x + 'px';",
                    "    cop.element.style.top = cop.y + 'px';",
                    "    cop.element.style.transform = `rotate(${driftAngle * 180 / Math.PI}deg)`;",
                    "  });",
                    "}"
                ],
                "css": [
                    ".cop {",
                    "  position: absolute;",
                    "  width: 30px;",
                    "  height: 30px;",
                    "  background: #00f;",
                    "  border-radius: 5px;",
                    "  transform-origin: center;",
                    "  transition: transform 0.3s ease-out;",
                    "  animation: sirenFlash 1s infinite;",
                    "  box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "}",
                    "",
                    "@keyframes sirenFlash {",
                    "  0% {",
                    "    background: #00f;",
                    "    box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "  }",
                    "  50% {",
                    "    background: #f00;",
                    "    box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);",
                    "  }",
                    "  100% {",
                    "    background: #00f;",
                    "    box-shadow: 0 0 15px rgba(0, 0, 255, 0.5);",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "terminal-ui-1",
        "pattern_name": "Terminal Interface",
        "type": "ui",
        "effectiveness_score": 0.8,
        "usage_count": 1,
        "content": {
            "context": "Text-based terminal interface with command responses",
            "metadata": {
                "ui_type": "terminal",
                "interaction_type": "text_input",
                "features": ["command_history", "hints"]
            }
        }
    },
    {
        "id": "visual-feedback-1",
        "pattern_name": "Dynamic Visual Feedback",
        "type": "effects",
        "effectiveness_score": 0.95,
        "usage_count": 2,
        "content": {
            "context": "Rich visual feedback for player actions and events",
            "metadata": {
                "effect_types": ["explosions", "screen_shake", "trails"],
                "animation_style": "particle_based",
                "feedback_timing": "immediate"
            }
        }
    },
    {
        "id": "powerup-system-1",
        "pattern_name": "Temporary Power-ups",
        "type": "mechanics",
        "effectiveness_score": 0.85,
        "usage_count": 2,
        "content": {
            "context": "Collectible power-ups with temporary effects",
            "metadata": {
                "spawn_type": "timed",
                "effect_duration": "temporary",
                "effect_types": ["speed_boost", "score_multiplier"]
            }
        }
    },
    {
        "id": "game-modes-1",
        "pattern_name": "Multiple Game Modes",
        "type": "structure",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Different gameplay modes with unique mechanics",
            "metadata": {
                "mode_types": ["classic", "survival", "time_trial", "stealth"],
                "progression": "unlockable",
                "difficulty_scaling": true
            }
        }
    },
    {
        "id": "synth-keyboard-1",
        "pattern_name": "Interactive Synth Keyboard",
        "type": "audio",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Interactive musical keyboard with advanced synth controls",
            "metadata": {
                "ui_type": "keyboard",
                "interaction_type": "keyboard_input",
                "features": ["waveform_control", "adsr_envelope", "effects"]
            },
            "implementation": {
                "html": [
                    "<div class='keyboard'>",
                    "  <div class='key' data-note='a'>A</div>",
                    "  <div class='key black' data-note='w'>W</div>",
                    "  <div class='key' data-note='s'>S</div>",
                    "  <!-- ... more keys ... -->",
                    "</div>",
                    "<div class='controls'>",
                    "  <div class='control'>",
                    "    <label for='waveform'>Waveform</label>",
                    "    <select id='waveform'>",
                    "      <option value='sawtooth'>Sawtooth</option>",
                    "      <option value='square'>Square</option>",
                    "      <option value='triangle'>Triangle</option>",
                    "      <option value='sine'>Sine</option>",
                    "    </select>",
                    "  </div>",
                    "  <!-- ADSR Controls -->",
                    "  <div class='control'>",
                    "    <label for='attack'>Attack</label>",
                    "    <input type='range' min='0.01' max='2' value='0.1' step='0.01' class='slider' id='attack'>",
                    "  </div>",
                    "  <!-- ... more controls ... -->",
                    "</div>"
                ],
                "css": [
                    ".keyboard {",
                    "  display: flex;",
                    "  justify-content: center;",
                    "  margin-bottom: 20px;",
                    "}",
                    ".key {",
                    "  width: 40px;",
                    "  height: 150px;",
                    "  background-color: #000922;",
                    "  border: 1px solid #3366aa;",
                    "  display: flex;",
                    "  justify-content: center;",
                    "  align-items: flex-end;",
                    "  cursor: pointer;",
                    "  transition: all 0.2s ease;",
                    "}",
                    ".key.black {",
                    "  width: 25px;",
                    "  height: 90px;",
                    "  background-color: #000011;",
                    "  margin: 0 -12px;",
                    "  z-index: 1;",
                    "}",
                    ".key:hover { background-color: #001144; }",
                    ".key.active { background-color: #002266; transform: translateY(3px); }"
                ],
                "javascript": [
                    "const audioContext = new AudioContext();",
                    "const oscillators = {};",
                    "",
                    "function playNote(note, frequency) {",
                    "  const osc = audioContext.createOscillator();",
                    "  const gainNode = audioContext.createGain();",
                    "  const filterNode = audioContext.createBiquadFilter();",
                    "",
                    "  osc.type = document.getElementById('waveform').value;",
                    "  osc.frequency.setValueAtTime(frequency, audioContext.currentTime);",
                    "",
                    "  // Apply ADSR envelope",
                    "  const attack = parseFloat(document.getElementById('attack').value);",
                    "  const decay = parseFloat(document.getElementById('decay').value);",
                    "  const sustain = parseFloat(document.getElementById('sustain').value);",
                    "",
                    "  gainNode.gain.setValueAtTime(0, audioContext.currentTime);",
                    "  gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + attack);",
                    "  gainNode.gain.linearRampToValueAtTime(sustain, audioContext.currentTime + attack + decay);",
                    "",
                    "  osc.connect(filterNode).connect(gainNode).connect(audioContext.destination);",
                    "  osc.start();",
                    "  oscillators[note] = { osc, gainNode };",
                    "}",
                    "",
                    "function stopNote(note) {",
                    "  if (oscillators[note]) {",
                    "    const release = parseFloat(document.getElementById('release').value);",
                    "    oscillators[note].gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + release);",
                    "    oscillators[note].osc.stop(audioContext.currentTime + release);",
                    "    delete oscillators[note];",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "shader-customization-1",
        "pattern_name": "Interactive Shader Customization",
        "type": "graphics",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Real-time customizable WebGL shader with interactive controls",
            "metadata": {
                "graphics_type": "webgl_shader",
                "interaction_type": "parameter_controls",
                "features": [
                    "color_palette",
                    "animation_speed",
                    "mirror_effect"
                ]
            },
            "implementation": {
                "html": [
                    "<canvas id='shaderCanvas'></canvas>",
                    "<div id='customizeMenu'>",
                    "  <label for='speed'>Animation Speed:</label>",
                    "  <input type='range' id='speed' min='0' max='2' step='0.1' value='1'>",
                    "  <label for='iterations'>Iterations:</label>",
                    "  <input type='range' id='iterations' min='1' max='10' step='1' value='4'>",
                    "  <!-- ... more controls ... -->",
                    "  <div class='color-picker'>",
                    "    <input type='color' id='color1' value='#808080'>",
                    "    <label for='color1'>Color 1</label>",
                    "  </div>",
                    "</div>"
                ],
                "shaders": {
                    "vertex": [
                        "attribute vec4 aVertexPosition;",
                        "void main() {",
                        "  gl_Position = aVertexPosition;",
                        "}"
                    ],
                    "fragment": [
                        "precision highp float;",
                        "uniform vec2 uResolution;",
                        "uniform float uTime;",
                        "uniform float uIterations;",
                        "uniform float uColorShift;",
                        "uniform float uZoom;",
                        "uniform vec3 uColor1;",
                        "uniform vec3 uColor2;",
                        "uniform vec3 uColor3;",
                        "uniform vec3 uColor4;",
                        "uniform float uMirrors;",
                        "",
                        "vec3 palette(float t) {",
                        "  vec3 a = uColor1;",
                        "  vec3 b = uColor2;",
                        "  vec3 c = uColor3;",
                        "  vec3 d = uColor4;",
                        "  return a + b*cos(6.28318*(c*t+d));",
                        "}",
                        "",
                        "void main() {",
                        "  vec2 uv = (gl_FragCoord.xy * 2.0 - uResolution.xy) / uResolution.y;",
                        "  uv *= uZoom;",
                        "  ",
                        "  // Apply mirror effect",
                        "  float angle = atan(uv.y, uv.x);",
                        "  float radius = length(uv);",
                        "  float sector = 6.28318 / uMirrors;",
                        "  angle = mod(angle, sector);",
                        "  if (mod(floor(atan(uv.y, uv.x) / sector), 2.0) == 1.0) {",
                        "    angle = sector - angle;",
                        "  }",
                        "  uv = vec2(cos(angle), sin(angle)) * radius;",
                        "  ",
                        "  vec3 finalColor = vec3(0.0);",
                        "  // ... shader computation ...",
                        "  gl_FragColor = vec4(finalColor, 1.0);",
                        "}"
                    ]
                },
                "javascript": [
                    "function initShaderProgram(gl, vsSource, fsSource) {",
                    "  const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);",
                    "  const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);",
                    "  const program = gl.createProgram();",
                    "  gl.attachShader(program, vertexShader);",
                    "  gl.attachShader(program, fragmentShader);",
                    "  gl.linkProgram(program);",
                    "  return program;",
                    "}",
                    "",
                    "function updateUniforms(gl, program) {",
                    "  gl.uniform2f(resolutionUniformLocation, canvas.width, canvas.height);",
                    "  gl.uniform1f(timeUniformLocation, time * speed);",
                    "  gl.uniform1f(iterationsUniformLocation, iterations);",
                    "  gl.uniform1f(colorShiftUniformLocation, colorShift);",
                    "  gl.uniform1f(zoomUniformLocation, zoom);",
                    "  gl.uniform1f(mirrorsUniformLocation, mirrors);",
                    "  gl.uniform3fv(color1UniformLocation, color1);",
                    "  // ... update other uniforms ...",
                    "}"
                ]
            }
        }
    },
    {
        "id": "typing-game-1",
        "pattern_name": "Fast-Paced Typing Game",
        "type": "mechanics",
        "effectiveness_score": 0.75,
        "usage_count": 1,
        "content": {
            "context": "Fast-paced typing game with word generation and instant feedback",
            "metadata": {
                "mechanics_type": "typing_game",
                "interaction_type": "keyboard_input",
                "strengths": [
                    "immediate feedback",
                    "fast-paced gameplay",
                    "engaging core mechanic"
                ],
                "weaknesses": [
                    "lacks scoring system",
                    "poor visual feedback",
                    "disconnected visual effects"
                ]
            },
            "implementation": {
                "state": [
                    "const gameState = {",
                    "  currentWord: '',",
                    "  typedWord: '',",
                    "  wordList: ['code', 'debug', 'syntax', 'function', 'variable', 'loop'],",
                    "  score: 0,",
                    "  wordsTyped: 0,",
                    "  accuracy: 100",
                    "};"
                ],
                "core_mechanics": [
                    "function generateNewWord() {",
                    "  const randomIndex = Math.floor(Math.random() * gameState.wordList.length);",
                    "  gameState.currentWord = gameState.wordList[randomIndex];",
                    "  gameState.typedWord = '';",
                    "  updateWordDisplay();",
                    "}",
                    "",
                    "function handleKeyPress(event) {",
                    "  const key = event.key.toLowerCase();",
                    "  ",
                    "  if (key === gameState.currentWord[gameState.typedWord.length]) {",
                    "    gameState.typedWord += key;",
                    "    updateWordDisplay();",
                    "    ",
                    "    if (gameState.typedWord === gameState.currentWord) {",
                    "      gameState.score += gameState.currentWord.length * 10;",
                    "      gameState.wordsTyped++;",
                    "      updateScore();",
                    "      generateNewWord();",
                    "    }",
                    "  } else {",
                    "    // Wrong key pressed",
                    "    gameState.accuracy = Math.max(0, gameState.accuracy - 1);",
                    "    updateAccuracy();",
                    "    shakeWord(); // Visual feedback for mistakes",
                    "  }",
                    "}"
                ],
                "display": [
                    "function updateWordDisplay() {",
                    "  const wordElement = document.getElementById('current-word');",
                    "  const typed = gameState.typedWord;",
                    "  const remaining = gameState.currentWord.slice(typed.length);",
                    "  ",
                    "  wordElement.innerHTML = `",
                    "    <span class='typed'>${typed}</span>",
                    "    <span class='remaining'>${remaining}</span>",
                    "  `;",
                    "}",
                    "",
                    "function updateScore() {",
                    "  document.getElementById('score').textContent = gameState.score;",
                    "  document.getElementById('words-typed').textContent = gameState.wordsTyped;",
                    "  document.getElementById('accuracy').textContent = gameState.accuracy + '%';",
                    "}"
                ],
                "css": [
                    ".game-container {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  align-items: center;",
                    "  justify-content: center;",
                    "  min-height: 100vh;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "}",
                    "",
                    "#current-word {",
                    "  font-size: 2.5rem;",
                    "  font-family: monospace;",
                    "  margin: 2rem 0;",
                    "}",
                    "",
                    ".typed {",
                    "  color: #4CAF50;",
                    "  text-decoration: underline;",
                    "}",
                    "",
                    ".remaining {",
                    "  color: #fff;",
                    "}",
                    "",
                    ".shake {",
                    "  animation: shake 0.2s ease-in-out;",
                    "}",
                    "",
                    "@keyframes shake {",
                    "  0%, 100% { transform: translateX(0); }",
                    "  25% { transform: translateX(-5px); }",
                    "  75% { transform: translateX(5px); }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "cursor-sound-1",
        "pattern_name": "Cursor Sound Trail",
        "type": "interaction",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Interactive cursor trail with synchronized audio feedback",
            "metadata": {
                "visual_type": "cursor_trail",
                "interaction_type": "mouse_move",
                "features": [
                    "audio_feedback",
                    "visual_trail",
                    "position_based_sound"
                ]
            },
            "implementation": {
                "html": [
                    "<canvas id='soundCanvas'></canvas>",
                    "<div id='cursor-trail'></div>"
                ],
                "audioSetup": [
                    "const audioCtx = new AudioContext();",
                    "const oscillator = audioCtx.createOscillator();",
                    "const gainNode = audioCtx.createGain();",
                    "",
                    "oscillator.connect(gainNode);",
                    "gainNode.connect(audioCtx.destination);",
                    "oscillator.start();"
                ],
                "eventHandlers": [
                    "document.addEventListener('mousemove', e => {",
                    "  // Update audio parameters based on cursor position",
                    "  const x = e.clientX / window.innerWidth;",
                    "  const y = e.clientY / window.innerHeight;",
                    "  ",
                    "  // Map X position to frequency (pitch)",
                    "  const minFreq = 220; // A3",
                    "  const maxFreq = 880; // A5",
                    "  const frequency = minFreq + (x * (maxFreq - minFreq));",
                    "  oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);",
                    "  ",
                    "  // Map Y position to volume",
                    "  const volume = 1 - (y * 0.8); // Higher = quieter",
                    "  gainNode.gain.setValueAtTime(volume * 0.5, audioCtx.currentTime);",
                    "  ",
                    "  // Create and animate trail particle",
                    "  createTrailParticle(e.clientX, e.clientY, frequency);",
                    "});"
                ],
                "trailEffects": [
                    "function createTrailParticle(x, y, freq) {",
                    "  const particle = document.createElement('div');",
                    "  particle.className = 'trail-particle';",
                    "  ",
                    "  // Map frequency to hue for color",
                    "  const hue = ((freq - 220) / (880 - 220)) * 360;",
                    "  particle.style.background = `hsla(${hue}, 80%, 60%, 0.8)`;",
                    "  ",
                    "  particle.style.left = x + 'px';",
                    "  particle.style.top = y + 'px';",
                    "  ",
                    "  document.body.appendChild(particle);",
                    "  ",
                    "  // Animate and remove",
                    "  requestAnimationFrame(() => {",
                    "    particle.style.transform = 'scale(0)';",
                    "    particle.style.opacity = '0';",
                    "  });",
                    "  ",
                    "  setTimeout(() => particle.remove(), 1000);",
                    "}"
                ],
                "css": [
                    "#cursor-trail {",
                    "  position: fixed;",
                    "  top: 0;",
                    "  left: 0;",
                    "  pointer-events: none;",
                    "  z-index: 9999;",
                    "}",
                    "",
                    ".trail-particle {",
                    "  position: absolute;",
                    "  width: 20px;",
                    "  height: 20px;",
                    "  border-radius: 50%;",
                    "  pointer-events: none;",
                    "  transform-origin: center;",
                    "  transform: scale(1);",
                    "  opacity: 0.8;",
                    "  transition: all 1s cubic-bezier(0.23, 1, 0.32, 1);",
                    "  mix-blend-mode: screen;",
                    "  filter: blur(2px);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "orbital-chaos-1",
        "pattern_name": "Orbital Chaos System",
        "type": "visual",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Visually striking orbital system with dynamic particle movement",
            "metadata": {
                "visual_type": "orbital_system",
                "interaction_type": "autonomous",
                "features": [
                    "central_attractor",
                    "multiple_orbits",
                    "particle_effects",
                    "dynamic_trails"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.createElement('canvas');",
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "// Central attractor",
                    "const center = {",
                    "  x: window.innerWidth / 2,",
                    "  y: window.innerHeight / 2,",
                    "  radius: 30,",
                    "  glow: 50",
                    "};",
                    "",
                    "// Orbital bodies",
                    "const orbiters = Array.from({ length: 8 }, (_, i) => ({",
                    "  angle: (Math.PI * 2 * i) / 8,",
                    "  radius: 15,",
                    "  orbitRadius: 150 + (i * 30),",
                    "  speed: 0.001 + (i * 0.0005),",
                    "  trail: []",
                    "}));"
                ],
                "render": [
                    "function render(timestamp) {",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';",
                    "  ctx.fillRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Render central attractor",
                    "  const gradient = ctx.createRadialGradient(",
                    "    center.x, center.y, 0,",
                    "    center.x, center.y, center.glow",
                    "  );",
                    "  gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');",
                    "  gradient.addColorStop(0.4, 'rgba(64, 190, 255, 0.8)');",
                    "  gradient.addColorStop(1, 'rgba(32, 90, 255, 0)');",
                    "  ",
                    "  ctx.beginPath();",
                    "  ctx.arc(center.x, center.y, center.radius, 0, Math.PI * 2);",
                    "  ctx.fillStyle = gradient;",
                    "  ctx.fill();",
                    "",
                    "  // Update and render orbiters",
                    "  orbiters.forEach((orbiter, i) => {",
                    "    orbiter.angle += orbiter.speed;",
                    "    ",
                    "    const x = center.x + Math.cos(orbiter.angle) * orbiter.orbitRadius;",
                    "    const y = center.y + Math.sin(orbiter.angle) * orbiter.orbitRadius;",
                    "    ",
                    "    // Update trail",
                    "    orbiter.trail.unshift({ x, y, alpha: 1 });",
                    "    if (orbiter.trail.length > 50) orbiter.trail.pop();",
                    "    ",
                    "    // Render trail",
                    "    orbiter.trail.forEach((point, j) => {",
                    "      point.alpha *= 0.95;",
                    "      ctx.beginPath();",
                    "      ctx.arc(point.x, point.y, orbiter.radius * (1 - j/50), 0, Math.PI * 2);",
                    "      ctx.fillStyle = `hsla(${(i * 45) + 200}, 100%, 60%, ${point.alpha})`;",
                    "      ctx.fill();",
                    "    });",
                    "    ",
                    "    // Render orbiter",
                    "    const orbGradient = ctx.createRadialGradient(",
                    "      x, y, 0,",
                    "      x, y, orbiter.radius * 2",
                    "    );",
                    "    orbGradient.addColorStop(0, `hsla(${(i * 45) + 200}, 100%, 70%, 1)`);",
                    "    orbGradient.addColorStop(0.5, `hsla(${(i * 45) + 200}, 100%, 50%, 0.5)`);",
                    "    orbGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');",
                    "    ",
                    "    ctx.beginPath();",
                    "    ctx.arc(x, y, orbiter.radius, 0, Math.PI * 2);",
                    "    ctx.fillStyle = orbGradient;",
                    "    ctx.fill();",
                    "  });",
                    "",
                    "  requestAnimationFrame(render);",
                    "}"
                ],
                "css": [
                    "canvas {",
                    "  position: fixed;",
                    "  top: 0;",
                    "  left: 0;",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "  background: #000;",
                    "}"
                ],
                "initialization": [
                    "canvas.width = window.innerWidth;",
                    "canvas.height = window.innerHeight;",
                    "document.body.appendChild(canvas);",
                    "requestAnimationFrame(render);"
                ]
            }
        }
    },
    {
        "id": "y2k-guestbook-1",
        "pattern_name": "Y2K Floating Guestbook",
        "type": "interactive",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Retro Y2K-style floating message board with nostalgic internet aesthetics",
            "metadata": {
                "visual_type": "retro_floating",
                "interaction_type": "message_input",
                "features": [
                    "floating_messages",
                    "y2k_aesthetics",
                    "persistent_messages",
                    "community_interaction"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='guestbook-container'>",
                    "  <div class='message-input'>",
                    "    <input type='text' id='message' placeholder='Leave your message...'>",
                    "    <button onclick='addMessage()'>✨ Post ✨</button>",
                    "  </div>",
                    "  <div id='message-space' class='message-space'></div>",
                    "</div>"
                ],
                "css": [
                    ".guestbook-container {",
                    "  background: linear-gradient(45deg, #000022, #000044);",
                    "  min-height: 100vh;",
                    "  overflow: hidden;",
                    "  position: relative;",
                    "}",
                    "",
                    ".message-input {",
                    "  position: fixed;",
                    "  bottom: 20px;",
                    "  left: 50%;",
                    "  transform: translateX(-50%);",
                    "  z-index: 1000;",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  padding: 15px;",
                    "  border-radius: 25px;",
                    "  border: 2px solid rgba(255, 255, 255, 0.2);",
                    "  backdrop-filter: blur(10px);",
                    "}",
                    "",
                    "input {",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  border: 1px solid rgba(255, 255, 255, 0.3);",
                    "  color: #fff;",
                    "  padding: 8px 15px;",
                    "  border-radius: 20px;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  margin-right: 10px;",
                    "}",
                    "",
                    "button {",
                    "  background: linear-gradient(45deg, #ff00ff, #00ffff);",
                    "  border: none;",
                    "  color: #fff;",
                    "  padding: 8px 20px;",
                    "  border-radius: 20px;",
                    "  cursor: pointer;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);",
                    "}",
                    "",
                    ".floating-message {",
                    "  position: absolute;",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  padding: 15px;",
                    "  border-radius: 15px;",
                    "  border: 2px solid rgba(255, 255, 255, 0.2);",
                    "  backdrop-filter: blur(5px);",
                    "  color: #fff;",
                    "  font-family: 'Comic Sans MS', cursive;",
                    "  text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);",
                    "  animation: float 20s linear infinite;",
                    "  white-space: nowrap;",
                    "  cursor: pointer;",
                    "  transition: transform 0.3s, filter 0.3s;",
                    "}",
                    "",
                    ".floating-message:hover {",
                    "  transform: scale(1.1);",
                    "  filter: brightness(1.2);",
                    "}",
                    "",
                    "@keyframes float {",
                    "  0% { transform: translate(100vw, random(100vh)); }",
                    "  100% { transform: translate(-100%, random(100vh)); }",
                    "}"
                ],
                "javascript": [
                    "const messages = [];",
                    "",
                    "function addMessage() {",
                    "  const input = document.getElementById('message');",
                    "  const text = input.value.trim();",
                    "  if (!text) return;",
                    "",
                    "  const message = {",
                    "    text,",
                    "    timestamp: Date.now(),",
                    "    color: `hsl(${Math.random() * 360}, 80%, 75%)`,",
                    "    speed: 10 + Math.random() * 10,",
                    "    verticalPos: Math.random() * 80 + 10",
                    "  };",
                    "",
                    "  messages.push(message);",
                    "  createFloatingMessage(message);",
                    "  input.value = '';",
                    "  ",
                    "  // Store in localStorage",
                    "  localStorage.setItem('guestbookMessages', JSON.stringify(messages));",
                    "}",
                    "",
                    "function createFloatingMessage(message) {",
                    "  const element = document.createElement('div');",
                    "  element.className = 'floating-message';",
                    "  element.textContent = message.text;",
                    "  element.style.top = `${message.verticalPos}vh`;",
                    "  element.style.color = message.color;",
                    "  element.style.animationDuration = `${message.speed}s`;",
                    "",
                    "  const messageSpace = document.getElementById('message-space');",
                    "  messageSpace.appendChild(element);",
                    "",
                    "  element.addEventListener('animationend', () => {",
                    "    element.remove();",
                    "    // Recreate the message for continuous flow",
                    "    setTimeout(() => createFloatingMessage(message), Math.random() * 5000);",
                    "  });",
                    "}",
                    "",
                    "// Load saved messages",
                    "window.addEventListener('load', () => {",
                    "  const saved = localStorage.getItem('guestbookMessages');",
                    "  if (saved) {",
                    "    const savedMessages = JSON.parse(saved);",
                    "    savedMessages.forEach(msg => {",
                    "      messages.push(msg);",
                    "      createFloatingMessage(msg);",
                    "    });",
                    "  }",
                    "});"
                ]
            }
        }
    },
    {
        "id": "harmonic-click-1",
        "pattern_name": "Harmonic Click Interaction",
        "type": "audio_visual",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Click-based musical interaction with spatial sound mapping and visual collision effects",
            "metadata": {
                "audio_type": "spatial_harmonic",
                "interaction_type": "click",
                "features": [
                    "position_based_pitch",
                    "collision_harmonics",
                    "visual_feedback",
                    "musical_scale"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.getElementById('canvas');",
                    "const ctx = canvas.getContext('2d');",
                    "const notes = [];",
                    "const palette = ['#ff6384', '#36a2eb', '#ffce56', '#9966ff', '#4bc0c0'];",
                    "",
                    "const audioCtx = new (window.AudioContext || window.webkitAudioContext)();",
                    "const masterGain = audioCtx.createGain();",
                    "masterGain.connect(audioCtx.destination);",
                    "masterGain.gain.value = 0.5;"
                ],
                "audioFunctions": [
                    "function playNote(freq) {",
                    "  const osc = audioCtx.createOscillator();",
                    "  osc.type = 'sine';",
                    "  osc.frequency.value = freq;",
                    "",
                    "  const gain = audioCtx.createGain();",
                    "  gain.connect(masterGain);",
                    "  osc.connect(gain);",
                    "",
                    "  // Envelope for smooth attack/release",
                    "  gain.gain.setValueAtTime(0, audioCtx.currentTime);",
                    "  gain.gain.linearRampToValueAtTime(1, audioCtx.currentTime + 0.01);",
                    "  gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);",
                    "",
                    "  osc.start();",
                    "  osc.stop(audioCtx.currentTime + 0.3);",
                    "  return osc;",
                    "}"
                ],
                "noteManagement": [
                    "function createNote(x, y, freq) {",
                    "  const note = {",
                    "    x,",
                    "    y,",
                    "    vx: Math.random() * 4 - 2,",
                    "    vy: Math.random() * 4 - 2,",
                    "    r: 10,",
                    "    freq,",
                    "    osc: playNote(freq),",
                    "    color: palette[Math.floor(Math.random() * palette.length)]",
                    "  };",
                    "  notes.push(note);",
                    "}",
                    "",
                    "function moveNote(note) {",
                    "  note.x += note.vx;",
                    "  note.y += note.vy;",
                    "  ",
                    "  // Bounce off walls",
                    "  if (note.x < note.r || note.x > width - note.r) note.vx *= -1;",
                    "  if (note.y < note.r || note.y > height - note.r) note.vy *= -1;",
                    "}"
                ],
                "collisionSystem": [
                    "function detectCollisions() {",
                    "  for (let i = 0; i < notes.length; i++) {",
                    "    for (let j = i + 1; j < notes.length; j++) {",
                    "      const dx = notes[i].x - notes[j].x;",
                    "      const dy = notes[i].y - notes[j].y;",
                    "      const dist = Math.sqrt(dx * dx + dy * dy);",
                    "",
                    "      if (dist < notes[i].r + notes[j].r) {",
                    "        // Calculate harmonic frequency",
                    "        const freq1 = notes[i].freq;",
                    "        const freq2 = notes[j].freq;",
                    "        const ratio = freq2 / freq1;",
                    "        const newFreq = freq1 * Math.pow(2, Math.round(Math.log2(ratio)) / 12);",
                    "",
                    "        // Play new harmonic note",
                    "        if (!oscillators[newFreq]) {",
                    "          oscillators[newFreq] = playNote(newFreq);",
                    "        }",
                    "",
                    "        // Update colliding notes",
                    "        notes[i].osc.stop();",
                    "        notes[j].osc.stop();",
                    "        notes[i].freq = notes[j].freq = newFreq;",
                    "        notes[i].osc = notes[j].osc = oscillators[newFreq];",
                    "        notes[i].color = notes[j].color = palette[Object.keys(oscillators).length % palette.length];",
                    "      }",
                    "    }",
                    "  }",
                    "}"
                ],
                "rendering": [
                    "function drawNote(note) {",
                    "  ctx.beginPath();",
                    "  ctx.arc(note.x, note.y, note.r, 0, 2 * Math.PI);",
                    "  ctx.fillStyle = note.color;",
                    "  ctx.fill();",
                    "}",
                    "",
                    "function drawBackground() {",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';",
                    "  ctx.fillRect(0, 0, width, height);",
                    "}"
                ],
                "eventHandlers": [
                    "canvas.addEventListener('click', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = e.clientX - rect.left;",
                    "  const y = e.clientY - rect.top;",
                    "",
                    "  // Map click position to musical frequency",
                    "  // A4 (440Hz) ± 6 semitones based on position",
                    "  const freq = 440 * Math.pow(2, (Math.random() * 2 - 1) * 6 / 12);",
                    "  createNote(x, y, freq);",
                    "});"
                ],
                "mainLoop": [
                    "function render() {",
                    "  ctx.clearRect(0, 0, width, height);",
                    "  drawBackground();",
                    "",
                    "  for (const note of notes) {",
                    "    drawNote(note);",
                    "    moveNote(note);",
                    "  }",
                    "",
                    "  detectCollisions();",
                    "  requestAnimationFrame(render);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "breakout-physics-1",
        "pattern_name": "Physics Breakout",
        "type": "game_mechanics",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Classic Breakout game with smooth physics and cursor-controlled paddle",
            "metadata": {
                "game_type": "arcade_classic",
                "interaction_type": "cursor_paddle",
                "features": [
                    "smooth_physics",
                    "collision_detection",
                    "paddle_control",
                    "brick_breaking"
                ],
                "strengths": [
                    "perfect playability",
                    "smooth cursor control",
                    "accurate physics"
                ],
                "potential_improvements": [
                    "scoring system",
                    "multiple levels",
                    "restart functionality"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.getElementById('gameCanvas');",
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "const state = {",
                    "  paddle: {",
                    "    width: 100,",
                    "    height: 10,",
                    "    y: canvas.height - 30",
                    "  },",
                    "  ball: {",
                    "    radius: 8,",
                    "    speed: 7,",
                    "    dx: 5,",
                    "    dy: -5",
                    "  },",
                    "  bricks: []",
                    "};"
                ],
                "brickSetup": [
                    "function createBricks() {",
                    "  const rows = 5;",
                    "  const cols = 8;",
                    "  const brickWidth = (canvas.width - 80) / cols;",
                    "  const brickHeight = 20;",
                    "",
                    "  for (let r = 0; r < rows; r++) {",
                    "    for (let c = 0; c < cols; c++) {",
                    "      state.bricks.push({",
                    "        x: c * (brickWidth + 10) + 40,",
                    "        y: r * (brickHeight + 10) + 40,",
                    "        width: brickWidth,",
                    "        height: brickHeight,",
                    "        color: `hsl(${(r * 30 + c * 15) % 360}, 70%, 60%)`",
                    "      });",
                    "    }",
                    "  }",
                    "}"
                ],
                "paddleControl": [
                    "canvas.addEventListener('mousemove', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const mouseX = e.clientX - rect.left;",
                    "  ",
                    "  // Smooth paddle movement with boundaries",
                    "  state.paddle.x = Math.max(",
                    "    Math.min(mouseX - state.paddle.width / 2, canvas.width - state.paddle.width),",
                    "    0",
                    "  );",
                    "});"
                ],
                "physics": [
                    "function updateBall() {",
                    "  const ball = state.ball;",
                    "  ball.x += ball.dx;",
                    "  ball.y += ball.dy;",
                    "",
                    "  // Wall collisions",
                    "  if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {",
                    "    ball.dx *= -1;",
                    "  }",
                    "  if (ball.y - ball.radius < 0) {",
                    "    ball.dy *= -1;",
                    "  }",
                    "",
                    "  // Paddle collision",
                    "  if (ball.y + ball.radius > state.paddle.y &&",
                    "      ball.x > state.paddle.x &&",
                    "      ball.x < state.paddle.x + state.paddle.width) {",
                    "    ",
                    "    // Calculate angle based on where ball hits paddle",
                    "    const hitPos = (ball.x - state.paddle.x) / state.paddle.width;",
                    "    const angle = (hitPos - 0.5) * Math.PI / 2;",
                    "",
                    "    ball.dx = ball.speed * Math.sin(angle);",
                    "    ball.dy = -ball.speed * Math.cos(angle);",
                    "  }",
                    "",
                    "  // Brick collisions",
                    "  for (let i = state.bricks.length - 1; i >= 0; i--) {",
                    "    const brick = state.bricks[i];",
                    "    if (ball.x + ball.radius > brick.x &&",
                    "        ball.x - ball.radius < brick.x + brick.width &&",
                    "        ball.y + ball.radius > brick.y &&",
                    "        ball.y - ball.radius < brick.y + brick.height) {",
                    "      ",
                    "      // Determine collision side and bounce accordingly",
                    "      const hitX = ball.x < brick.x + brick.width / 2 ? brick.x : brick.x + brick.width;",
                    "      const hitY = ball.y < brick.y + brick.height / 2 ? brick.y : brick.y + brick.height;",
                    "      ",
                    "      if (Math.abs(ball.x - hitX) > Math.abs(ball.y - hitY)) {",
                    "        ball.dx *= -1;",
                    "      } else {",
                    "        ball.dy *= -1;",
                    "      }",
                    "      ",
                    "      state.bricks.splice(i, 1);",
                    "    }",
                    "  }",
                    "}"
                ],
                "rendering": [
                    "function render() {",
                    "  ctx.clearRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Draw paddle",
                    "  ctx.fillStyle = '#4CAF50';",
                    "  ctx.fillRect(state.paddle.x, state.paddle.y, state.paddle.width, state.paddle.height);",
                    "",
                    "  // Draw ball",
                    "  ctx.beginPath();",
                    "  ctx.arc(state.ball.x, state.ball.y, state.ball.radius, 0, Math.PI * 2);",
                    "  ctx.fillStyle = '#fff';",
                    "  ctx.fill();",
                    "  ctx.closePath();",
                    "",
                    "  // Draw bricks",
                    "  state.bricks.forEach(brick => {",
                    "    ctx.fillStyle = brick.color;",
                    "    ctx.fillRect(brick.x, brick.y, brick.width, brick.height);",
                    "  });",
                    "}"
                ],
                "gameLoop": [
                    "function gameLoop() {",
                    "  updateBall();",
                    "  render();",
                    "  requestAnimationFrame(gameLoop);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "firework-animation-1",
        "pattern_name": "Click-Triggered Fireworks",
        "type": "animation",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Simple but accurate firework animation with launch and explosion physics",
            "metadata": {
                "animation_type": "particle_system",
                "interaction_type": "click_trigger",
                "features": [
                    "launch_trajectory",
                    "explosion_physics",
                    "particle_decay",
                    "realistic_timing"
                ],
                "strengths": [
                    "accurate physics simulation",
                    "natural motion",
                    "visual appeal",
                    "performance efficient"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.getElementById('canvas');",
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "const fireworks = [];",
                    "const particles = [];",
                    "",
                    "class Firework {",
                    "  constructor(x, y) {",
                    "    this.x = x;",
                    "    this.y = canvas.height;",
                    "    this.targetY = y;",
                    "    this.speed = 15;",
                    "    this.angle = Math.atan2(y - canvas.height, x - x);",
                    "    this.velocity = {",
                    "      x: Math.sin(this.angle) * this.speed,",
                    "      y: Math.cos(this.angle) * this.speed - 15",
                    "    };",
                    "    this.brightness = 255;",
                    "    this.trail = [];",
                    "  }",
                    "}"
                ],
                "particleSystem": [
                    "class Particle {",
                    "  constructor(x, y, hue) {",
                    "    this.x = x;",
                    "    this.y = y;",
                    "    this.hue = hue;",
                    "    this.brightness = Math.random() * 50 + 50;",
                    "    this.alpha = 1;",
                    "    ",
                    "    // Explosion velocity",
                    "    const angle = Math.random() * Math.PI * 2;",
                    "    const speed = Math.random() * 8 + 2;",
                    "    this.velocity = {",
                    "      x: Math.cos(angle) * speed,",
                    "      y: Math.sin(angle) * speed",
                    "    };",
                    "    ",
                    "    // Gravity and fade",
                    "    this.gravity = 0.2;",
                    "    this.friction = 0.95;",
                    "    this.fadeSpeed = Math.random() * 0.03 + 0.02;",
                    "  }",
                    "}"
                ],
                "animation": [
                    "function updateFirework(fw) {",
                    "  // Update position",
                    "  fw.x += fw.velocity.x;",
                    "  fw.y -= fw.velocity.y;",
                    "  fw.velocity.y -= 0.3; // Gravity",
                    "",
                    "  // Trail effect",
                    "  fw.trail.push({ x: fw.x, y: fw.y, brightness: fw.brightness });",
                    "  if (fw.trail.length > 5) fw.trail.shift();",
                    "",
                    "  // Check if reached peak",
                    "  if (fw.velocity.y <= 0.5 && !fw.exploded) {",
                    "    createExplosion(fw.x, fw.y);",
                    "    fw.exploded = true;",
                    "  }",
                    "}",
                    "",
                    "function updateParticle(p) {",
                    "  // Update position",
                    "  p.x += p.velocity.x;",
                    "  p.y += p.velocity.y;",
                    "  ",
                    "  // Apply physics",
                    "  p.velocity.x *= p.friction;",
                    "  p.velocity.y *= p.friction;",
                    "  p.velocity.y += p.gravity;",
                    "  ",
                    "  // Fade out",
                    "  p.alpha -= p.fadeSpeed;",
                    "}"
                ],
                "rendering": [
                    "function render() {",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';",
                    "  ctx.fillRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Render fireworks",
                    "  fireworks.forEach((fw, i) => {",
                    "    if (!fw.exploded) {",
                    "      ctx.beginPath();",
                    "      ctx.moveTo(fw.trail[0].x, fw.trail[0].y);",
                    "      fw.trail.forEach(point => {",
                    "        ctx.lineTo(point.x, point.y);",
                    "      });",
                    "      ctx.strokeStyle = `hsla(45, 100%, ${point.brightness}%, 0.5)`;",
                    "      ctx.stroke();",
                    "    }",
                    "    updateFirework(fw);",
                    "    if (fw.exploded && !particles.some(p => p.parentId === i)) {",
                    "      fireworks.splice(i, 1);",
                    "    }",
                    "  });",
                    "",
                    "  // Render particles",
                    "  particles.forEach((p, i) => {",
                    "    if (p.alpha <= 0) {",
                    "      particles.splice(i, 1);",
                    "      return;",
                    "    }",
                    "    ctx.beginPath();",
                    "    ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);",
                    "    ctx.fillStyle = `hsla(${p.hue}, 100%, ${p.brightness}%, ${p.alpha})`;",
                    "    ctx.fill();",
                    "    updateParticle(p);",
                    "  });",
                    "",
                    "  requestAnimationFrame(render);",
                    "}"
                ],
                "eventHandlers": [
                    "canvas.addEventListener('click', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = e.clientX - rect.left;",
                    "  const y = e.clientY - rect.top;",
                    "  fireworks.push(new Firework(x, y));",
                    "});",
                    "",
                    "function createExplosion(x, y) {",
                    "  const particleCount = 50;",
                    "  const hue = Math.random() * 360;",
                    "  ",
                    "  for (let i = 0; i < particleCount; i++) {",
                    "    particles.push(new Particle(x, y, hue));",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "ms-paint-clone-1",
        "pattern_name": "MS Paint Recreation",
        "type": "application",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Faithful recreation of classic MS Paint with modern web technologies",
            "metadata": {
                "app_type": "drawing_tool",
                "interaction_type": "multi_tool",
                "features": [
                    "drawing_tools",
                    "shape_tools",
                    "color_picker",
                    "save_functionality",
                    "classic_ui"
                ],
                "strengths": [
                    "authentic recreation",
                    "complete functionality",
                    "practical output",
                    "nostalgic interface"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='paint-app'>",
                    "  <div class='toolbar'>",
                    "    <div class='tool-group'>",
                    "      <button class='tool' data-tool='pencil'>✏️</button>",
                    "      <button class='tool' data-tool='brush'>🖌️</button>",
                    "      <button class='tool' data-tool='eraser'>⌫</button>",
                    "      <button class='tool' data-tool='fill'>🪣</button>",
                    "    </div>",
                    "    <div class='shape-group'>",
                    "      <button class='tool' data-shape='rect'>□</button>",
                    "      <button class='tool' data-shape='circle'>○</button>",
                    "      <button class='tool' data-shape='line'>╱</button>",
                    "    </div>",
                    "    <div class='color-group'>",
                    "      <input type='color' id='colorPicker'>",
                    "      <div class='color-palette'>",
                    "        <!-- Classic MS Paint colors -->",
                    "        <div class='color-swatch' style='background: #000000'></div>",
                    "        <div class='color-swatch' style='background: #808080'></div>",
                    "        <div class='color-swatch' style='background: #800000'></div>",
                    "        <!-- ... more colors ... -->",
                    "      </div>",
                    "    </div>",
                    "    <div class='size-group'>",
                    "      <input type='range' id='sizeSlider' min='1' max='50' value='1'>",
                    "    </div>",
                    "    <div class='file-group'>",
                    "      <button id='saveBtn'>💾 Save</button>",
                    "      <button id='clearBtn'>🗑️ Clear</button>",
                    "    </div>",
                    "  </div>",
                    "  <canvas id='paintCanvas'></canvas>",
                    "</div>"
                ],
                "css": [
                    ".paint-app {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  height: 100vh;",
                    "  background: #f0f0f0;",
                    "  font-family: 'Segoe UI', Tahoma, sans-serif;",
                    "}",
                    "",
                    ".toolbar {",
                    "  display: flex;",
                    "  gap: 10px;",
                    "  padding: 10px;",
                    "  background: #e1e1e1;",
                    "  border-bottom: 1px solid #999;",
                    "}",
                    "",
                    ".tool-group, .shape-group, .color-group, .file-group {",
                    "  display: flex;",
                    "  gap: 5px;",
                    "  padding: 5px;",
                    "  border: 1px solid #999;",
                    "  border-radius: 3px;",
                    "  background: #f5f5f5;",
                    "}",
                    "",
                    ".tool {",
                    "  width: 30px;",
                    "  height: 30px;",
                    "  border: 1px solid #999;",
                    "  background: #fff;",
                    "  cursor: pointer;",
                    "}",
                    "",
                    ".tool.active {",
                    "  background: #cce8ff;",
                    "  border-color: #66b5ff;",
                    "}",
                    "",
                    ".color-palette {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(8, 1fr);",
                    "  gap: 2px;",
                    "}",
                    "",
                    ".color-swatch {",
                    "  width: 15px;",
                    "  height: 15px;",
                    "  border: 1px solid #999;",
                    "  cursor: pointer;",
                    "}",
                    "",
                    "#paintCanvas {",
                    "  flex: 1;",
                    "  background: #fff;",
                    "  cursor: crosshair;",
                    "}"
                ],
                "javascript": [
                    "const canvas = document.getElementById('paintCanvas');",
                    "const ctx = canvas.getContext('2d');",
                    "let isDrawing = false;",
                    "let currentTool = 'pencil';",
                    "let currentColor = '#000000';",
                    "let currentSize = 1;",
                    "",
                    "// Tool handlers",
                    "const tools = {",
                    "  pencil: {",
                    "    start(e) {",
                    "      isDrawing = true;",
                    "      ctx.beginPath();",
                    "      ctx.moveTo(e.offsetX, e.offsetY);",
                    "    },",
                    "    move(e) {",
                    "      if (!isDrawing) return;",
                    "      ctx.lineTo(e.offsetX, e.offsetY);",
                    "      ctx.stroke();",
                    "    },",
                    "    end() {",
                    "      isDrawing = false;",
                    "      ctx.closePath();",
                    "    }",
                    "  },",
                    "  brush: {",
                    "    start(e) {",
                    "      isDrawing = true;",
                    "      ctx.beginPath();",
                    "      ctx.lineCap = 'round';",
                    "      ctx.lineJoin = 'round';",
                    "      ctx.moveTo(e.offsetX, e.offsetY);",
                    "    },",
                    "    move(e) {",
                    "      if (!isDrawing) return;",
                    "      ctx.lineTo(e.offsetX, e.offsetY);",
                    "      ctx.stroke();",
                    "    },",
                    "    end() {",
                    "      isDrawing = false;",
                    "      ctx.closePath();",
                    "    }",
                    "  },",
                    "  eraser: {",
                    "    start(e) {",
                    "      ctx.save();",
                    "      ctx.globalCompositeOperation = 'destination-out';",
                    "      tools.brush.start(e);",
                    "    },",
                    "    move: tools.brush.move,",
                    "    end(e) {",
                    "      tools.brush.end(e);",
                    "      ctx.restore();",
                    "    }",
                    "  },",
                    "  fill: {",
                    "    start(e) {",
                    "      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);",
                    "      floodFill(imageData, e.offsetX, e.offsetY, currentColor);",
                    "      ctx.putImageData(imageData, 0, 0);",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "// Shape drawing",
                    "const shapes = {",
                    "  rect: {",
                    "    draw(start, end) {",
                    "      ctx.beginPath();",
                    "      ctx.rect(",
                    "        Math.min(start.x, end.x),",
                    "        Math.min(start.y, end.y),",
                    "        Math.abs(end.x - start.x),",
                    "        Math.abs(end.y - start.y)",
                    "      );",
                    "      if (ctx.fillStyle !== 'transparent') ctx.fill();",
                    "      ctx.stroke();",
                    "    }",
                    "  },",
                    "  circle: {",
                    "    draw(start, end) {",
                    "      const radius = Math.sqrt(",
                    "        Math.pow(end.x - start.x, 2) +",
                    "        Math.pow(end.y - start.y, 2)",
                    "      );",
                    "      ctx.beginPath();",
                    "      ctx.arc(start.x, start.y, radius, 0, Math.PI * 2);",
                    "      if (ctx.fillStyle !== 'transparent') ctx.fill();",
                    "      ctx.stroke();",
                    "    }",
                    "  },",
                    "  line: {",
                    "    draw(start, end) {",
                    "      ctx.beginPath();",
                    "      ctx.moveTo(start.x, start.y);",
                    "      ctx.lineTo(end.x, end.y);",
                    "      ctx.stroke();",
                    "    }",
                    "  }",
                    "};",
                    "",
                    "// Save functionality",
                    "document.getElementById('saveBtn').addEventListener('click', () => {",
                    "  const link = document.createElement('a');",
                    "  link.download = 'my-drawing.png';",
                    "  link.href = canvas.toDataURL();",
                    "  link.click();",
                    "});"
                ],
                "eventHandlers": [
                    "canvas.addEventListener('mousedown', e => {",
                    "  const tool = tools[currentTool];",
                    "  if (tool) tool.start(e);",
                    "});",
                    "",
                    "canvas.addEventListener('mousemove', e => {",
                    "  const tool = tools[currentTool];",
                    "  if (tool) tool.move(e);",
                    "});",
                    "",
                    "canvas.addEventListener('mouseup', e => {",
                    "  const tool = tools[currentTool];",
                    "  if (tool) tool.end(e);",
                    "});",
                    "",
                    "document.querySelectorAll('.tool').forEach(btn => {",
                    "  btn.addEventListener('click', () => {",
                    "    document.querySelector('.tool.active')?.classList.remove('active');",
                    "    btn.classList.add('active');",
                    "    currentTool = btn.dataset.tool || currentTool;",
                    "  });",
                    "});"
                ]
            }
        }
    },
    {
        "id": "neon-terminal-1",
        "pattern_name": "Neon Hacker Terminal",
        "type": "visual_style",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Dark mode terminal interface with striking neon color palette",
            "metadata": {
                "style_type": "terminal",
                "color_scheme": "neon_dark",
                "features": [
                    "high_contrast",
                    "neon_accents",
                    "dark_background",
                    "terminal_aesthetics"
                ],
                "strengths": [
                    "beautiful color harmony",
                    "excellent readability",
                    "modern dark mode",
                    "versatile application"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='terminal-container'>",
                    "  <div class='terminal-header'>",
                    "    <div class='controls'>",
                    "      <span class='control close'></span>",
                    "      <span class='control minimize'></span>",
                    "      <span class='control maximize'></span>",
                    "    </div>",
                    "    <div class='title'>terminal</div>",
                    "  </div>",
                    "  <div class='terminal-content'>",
                    "    <div class='output'></div>",
                    "    <div class='input-line'>",
                    "      <span class='prompt'>></span>",
                    "      <input type='text' class='command-input' autofocus>",
                    "    </div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ":root {",
                    "  --bg-primary: #0a0a0f;",
                    "  --bg-secondary: #12121a;",
                    "  --neon-green: #00ff9d;",
                    "  --neon-blue: #00b3ff;",
                    "  --neon-pink: #ff00ff;",
                    "  --neon-yellow: #ffff00;",
                    "  --text-primary: #e0e0ff;",
                    "  --text-dim: rgba(224, 224, 255, 0.6);",
                    "}",
                    "",
                    ".terminal-container {",
                    "  background: var(--bg-primary);",
                    "  border: 1px solid var(--neon-blue);",
                    "  border-radius: 8px;",
                    "  box-shadow: 0 0 20px rgba(0, 179, 255, 0.2);",
                    "  overflow: hidden;",
                    "  font-family: 'Fira Code', monospace;",
                    "}",
                    "",
                    ".terminal-header {",
                    "  background: var(--bg-secondary);",
                    "  padding: 8px 16px;",
                    "  display: flex;",
                    "  align-items: center;",
                    "  border-bottom: 1px solid var(--neon-blue);",
                    "}",
                    "",
                    ".controls {",
                    "  display: flex;",
                    "  gap: 8px;",
                    "}",
                    "",
                    ".control {",
                    "  width: 12px;",
                    "  height: 12px;",
                    "  border-radius: 50%;",
                    "  border: 1px solid rgba(255, 255, 255, 0.2);",
                    "}",
                    "",
                    ".control.close { background: var(--neon-pink); }",
                    ".control.minimize { background: var(--neon-yellow); }",
                    ".control.maximize { background: var(--neon-green); }",
                    "",
                    ".title {",
                    "  color: var(--text-dim);",
                    "  margin-left: 20px;",
                    "  font-size: 14px;",
                    "}",
                    "",
                    ".terminal-content {",
                    "  padding: 20px;",
                    "  min-height: 300px;",
                    "}",
                    "",
                    ".output {",
                    "  color: var(--text-primary);",
                    "  margin-bottom: 20px;",
                    "  line-height: 1.5;",
                    "}",
                    "",
                    ".input-line {",
                    "  display: flex;",
                    "  align-items: center;",
                    "  gap: 8px;",
                    "}",
                    "",
                    ".prompt {",
                    "  color: var(--neon-green);",
                    "  font-weight: bold;",
                    "}",
                    "",
                    ".command-input {",
                    "  background: transparent;",
                    "  border: none;",
                    "  color: var(--text-primary);",
                    "  font-family: inherit;",
                    "  font-size: inherit;",
                    "  flex: 1;",
                    "  outline: none;",
                    "}",
                    "",
                    "/* Neon text effects */",
                    ".neon-text {",
                    "  color: var(--neon-blue);",
                    "  text-shadow: 0 0 5px var(--neon-blue),",
                    "               0 0 10px var(--neon-blue),",
                    "               0 0 20px var(--neon-blue);",
                    "}",
                    "",
                    ".neon-text.error {",
                    "  color: var(--neon-pink);",
                    "  text-shadow: 0 0 5px var(--neon-pink),",
                    "               0 0 10px var(--neon-pink),",
                    "               0 0 20px var(--neon-pink);",
                    "}",
                    "",
                    ".neon-text.success {",
                    "  color: var(--neon-green);",
                    "  text-shadow: 0 0 5px var(--neon-green),",
                    "               0 0 10px var(--neon-green),",
                    "               0 0 20px var(--neon-green);",
                    "}",
                    "",
                    "/* Scanline effect */",
                    "@keyframes scanline {",
                    "  0% { transform: translateY(0); }",
                    "  100% { transform: translateY(100%); }",
                    "}",
                    "",
                    ".terminal-content::after {",
                    "  content: '';",
                    "  position: absolute;",
                    "  top: 0;",
                    "  left: 0;",
                    "  right: 0;",
                    "  height: 2px;",
                    "  background: rgba(0, 179, 255, 0.1);",
                    "  animation: scanline 2s linear infinite;",
                    "  pointer-events: none;",
                    "}"
                ],
                "colorPalette": {
                    "background": {
                        "primary": "#0a0a0f",
                        "secondary": "#12121a"
                    },
                    "neon": {
                        "green": "#00ff9d",
                        "blue": "#00b3ff",
                        "pink": "#ff00ff",
                        "yellow": "#ffff00"
                    },
                    "text": {
                        "primary": "#e0e0ff",
                        "dimmed": "rgba(224, 224, 255, 0.6)"
                    }
                }
            }
        }
    },
    {
        "id": "air-hockey-1",
        "pattern_name": "Air Hockey Physics",
        "type": "game_mechanics",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Fluid air hockey game with realistic physics and intelligent AI opponent",
            "metadata": {
                "game_type": "sports_simulation",
                "interaction_type": "cursor_physics",
                "features": [
                    "smooth_controls",
                    "realistic_collisions",
                    "ai_opponent",
                    "immersive_gameplay"
                ],
                "strengths": [
                    "fluid cursor movement",
                    "realistic physics",
                    "engaging AI",
                    "cohesive aesthetics"
                ]
            },
            "implementation": {
                "setup": [
                    "const canvas = document.getElementById('gameCanvas');",
                    "const ctx = canvas.getContext('2d');",
                    "",
                    "const state = {",
                    "  playerPaddle: {",
                    "    x: canvas.width * 0.2,",
                    "    y: canvas.height / 2,",
                    "    radius: 30,",
                    "    speed: 30",
                    "  },",
                    "  aiPaddle: {",
                    "    x: canvas.width * 0.8,",
                    "    y: canvas.height / 2,",
                    "    radius: 30,",
                    "    speed: 15",
                    "  },",
                    "  puck: {",
                    "    x: canvas.width / 2,",
                    "    y: canvas.height / 2,",
                    "    radius: 15,",
                    "    velocity: { x: 0, y: 0 },",
                    "    friction: 0.99",
                    "  },",
                    "  goals: {",
                    "    width: 10,",
                    "    height: 150",
                    "  }",
                    "};"
                ],
                "physics": [
                    "function updatePhysics() {",
                    "  const puck = state.puck;",
                    "  ",
                    "  // Apply friction",
                    "  puck.velocity.x *= puck.friction;",
                    "  puck.velocity.y *= puck.friction;",
                    "  ",
                    "  // Update position",
                    "  puck.x += puck.velocity.x;",
                    "  puck.y += puck.velocity.y;",
                    "  ",
                    "  // Wall collisions",
                    "  if (puck.y - puck.radius < 0 || puck.y + puck.radius > canvas.height) {",
                    "    puck.velocity.y *= -0.9;",
                    "    puck.y = puck.y - puck.radius < 0 ? puck.radius : canvas.height - puck.radius;",
                    "  }",
                    "",
                    "  // Paddle collisions",
                    "  [state.playerPaddle, state.aiPaddle].forEach(paddle => {",
                    "    const dx = puck.x - paddle.x;",
                    "    const dy = puck.y - paddle.y;",
                    "    const distance = Math.sqrt(dx * dx + dy * dy);",
                    "",
                    "    if (distance < puck.radius + paddle.radius) {",
                    "      // Calculate collision angle and new velocity",
                    "      const angle = Math.atan2(dy, dx);",
                    "      const speed = Math.sqrt(",
                    "        puck.velocity.x * puck.velocity.x +",
                    "        puck.velocity.y * puck.velocity.y",
                    "      );",
                    "",
                    "      puck.velocity.x = Math.cos(angle) * speed * 1.5;",
                    "      puck.velocity.y = Math.sin(angle) * speed * 1.5;",
                    "",
                    "      // Separate objects to prevent sticking",
                    "      const overlap = (puck.radius + paddle.radius) - distance;",
                    "      puck.x += Math.cos(angle) * overlap;",
                    "      puck.y += Math.sin(angle) * overlap;",
                    "    }",
                    "  });",
                    "}"
                ],
                "aiLogic": [
                    "function updateAI() {",
                    "  const ai = state.aiPaddle;",
                    "  const puck = state.puck;",
                    "  const predictedY = puck.y + (puck.velocity.y * ",
                    "    ((ai.x - puck.x) / Math.max(Math.abs(puck.velocity.x), 1)));",
                    "",
                    "  // Defensive position when puck is on player's side",
                    "  if (puck.x < canvas.width / 2) {",
                    "    const homeY = canvas.height / 2;",
                    "    ai.y += (homeY - ai.y) * 0.1;",
                    "  } else {",
                    "    // Aggressive position when puck is on AI's side",
                    "    if (Math.abs(puck.velocity.x) > 1) {",
                    "      // Intercept based on prediction",
                    "      ai.y += (predictedY - ai.y) * 0.2;",
                    "    } else {",
                    "      // Move directly towards puck when it's slow",
                    "      ai.y += (puck.y - ai.y) * 0.1;",
                    "    }",
                    "  }",
                    "",
                    "  // Keep AI paddle within bounds",
                    "  ai.y = Math.max(ai.radius, Math.min(canvas.height - ai.radius, ai.y));",
                    "}"
                ],
                "playerControl": [
                    "canvas.addEventListener('mousemove', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const mouseX = e.clientX - rect.left;",
                    "  const mouseY = e.clientY - rect.top;",
                    "  ",
                    "  // Smooth player paddle movement with boundary checking",
                    "  const paddle = state.playerPaddle;",
                    "  const targetX = Math.min(canvas.width / 2 - paddle.radius,",
                    "                          Math.max(paddle.radius, mouseX));",
                    "  const targetY = Math.min(canvas.height - paddle.radius,",
                    "                          Math.max(paddle.radius, mouseY));",
                    "  ",
                    "  // Smooth interpolation",
                    "  paddle.x += (targetX - paddle.x) * 0.3;",
                    "  paddle.y += (targetY - paddle.y) * 0.3;",
                    "});"
                ],
                "rendering": [
                    "function render() {",
                    "  ctx.clearRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Draw center line",
                    "  ctx.beginPath();",
                    "  ctx.setLineDash([10, 10]);",
                    "  ctx.moveTo(canvas.width / 2, 0);",
                    "  ctx.lineTo(canvas.width / 2, canvas.height);",
                    "  ctx.strokeStyle = '#666';",
                    "  ctx.stroke();",
                    "  ctx.setLineDash([]);",
                    "",
                    "  // Draw paddles",
                    "  [state.playerPaddle, state.aiPaddle].forEach(paddle => {",
                    "    ctx.beginPath();",
                    "    ctx.arc(paddle.x, paddle.y, paddle.radius, 0, Math.PI * 2);",
                    "    ctx.fillStyle = '#fff';",
                    "    ctx.fill();",
                    "    ctx.strokeStyle = '#333';",
                    "    ctx.stroke();",
                    "  });",
                    "",
                    "  // Draw puck with shadow",
                    "  ctx.beginPath();",
                    "  ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';",
                    "  ctx.shadowBlur = 10;",
                    "  ctx.arc(state.puck.x, state.puck.y, state.puck.radius, 0, Math.PI * 2);",
                    "  ctx.fillStyle = '#333';",
                    "  ctx.fill();",
                    "  ctx.shadowColor = 'transparent';",
                    "",
                    "  // Draw goals",
                    "  ctx.fillStyle = '#666';",
                    "  ctx.fillRect(0, (canvas.height - state.goals.height) / 2,",
                    "               state.goals.width, state.goals.height);",
                    "  ctx.fillRect(canvas.width - state.goals.width,",
                    "               (canvas.height - state.goals.height) / 2,",
                    "               state.goals.width, state.goals.height);",
                    "}"
                ],
                "gameLoop": [
                    "function gameLoop() {",
                    "  updatePhysics();",
                    "  updateAI();",
                    "  render();",
                    "  requestAnimationFrame(gameLoop);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "bytebeat-generator-1",
        "pattern_name": "Modular Bytebeat Generator",
        "type": "audio_visual_app",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Highly modular bytebeat music generator with responsive visualization and quantization",
            "metadata": {
                "app_type": "audio_generator",
                "interaction_type": "multi_module",
                "features": [
                    "modular_audio",
                    "visual_feedback",
                    "beat_quantization",
                    "screenshot_capture",
                    "responsive_layout"
                ],
                "strengths": [
                    "excellent modularity",
                    "intuitive interface",
                    "visual aesthetics",
                    "responsive design",
                    "practical features"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='bytebeat-studio'>",
                    "  <div class='module-rack'>",
                    "    <div class='module oscillator'>",
                    "      <div class='module-header'>",
                    "        <span class='emoji'>🎹</span>",
                    "        <h3>Oscillator</h3>",
                    "      </div>",
                    "      <div class='controls'>",
                    "        <select class='wave-type'>",
                    "          <option value='sine'>🌊 Sine</option>",
                    "          <option value='square'>⬜ Square</option>",
                    "          <option value='saw'>⚡ Saw</option>",
                    "          <option value='noise'>❄️ Noise</option>",
                    "        </select>",
                    "        <div class='slider-group'>",
                    "          <label>Frequency</label>",
                    "          <input type='range' min='1' max='1000' value='440'>",
                    "        </div>",
                    "      </div>",
                    "",
                    "    <div class='module sequencer'>",
                    "      <div class='module-header'>",
                    "        <span class='emoji'>🎼</span>",
                    "        <h3>Sequencer</h3>",
                    "      </div>",
                    "      <div class='grid-container'>",
                    "        <!-- Dynamic grid generation -->",
                    "      </div>",
                    "      <div class='controls'>",
                    "        <button class='play-pause'>▶️</button>",
                    "        <button class='quantize'>📏</button>",
                    "        <input type='number' class='bpm' value='120'>",
                    "      </div>",
                    "    </div>",
                    "",
                    "    <div class='module effects'>",
                    "      <div class='module-header'>",
                    "        <span class='emoji'>✨</span>",
                    "        <h3>Effects</h3>",
                    "      </div>",
                    "      <div class='effects-rack'>",
                    "        <div class='effect'>",
                    "          <label>Delay</label>",
                    "          <input type='range' class='delay-time'>",
                    "          <input type='range' class='delay-feedback'>",
                    "        </div>",
                    "        <div class='effect'>",
                    "          <label>Filter</label>",
                    "          <input type='range' class='filter-freq'>",
                    "          <input type='range' class='filter-res'>",
                    "        </div>",
                    "      </div>",
                    "    </div>",
                    "  </div>",
                    "",
                    "  <div class='visualizer-container'>",
                    "    <canvas id='visualizer'></canvas>",
                    "    <button class='screenshot'>📸</button>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".bytebeat-studio {",
                    "  display: grid;",
                    "  grid-template-columns: 300px 1fr;",
                    "  gap: 20px;",
                    "  padding: 20px;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "  height: 100vh;",
                    "  font-family: 'Inter', system-ui;",
                    "}",
                    "",
                    ".module-rack {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 15px;",
                    "}",
                    "",
                    ".module {",
                    "  background: #2a2a2a;",
                    "  border-radius: 10px;",
                    "  padding: 15px;",
                    "  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);",
                    "}",
                    "",
                    ".module-header {",
                    "  display: flex;",
                    "  align-items: center;",
                    "  gap: 10px;",
                    "  margin-bottom: 15px;",
                    "}",
                    "",
                    ".emoji {",
                    "  font-size: 1.5em;",
                    "}",
                    "",
                    ".controls {",
                    "  display: grid;",
                    "  gap: 10px;",
                    "}",
                    "",
                    "select, input[type='range'] {",
                    "  width: 100%;",
                    "  padding: 8px;",
                    "  background: #3a3a3a;",
                    "  border: none;",
                    "  border-radius: 5px;",
                    "  color: #fff;",
                    "}",
                    "",
                    ".grid-container {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(16, 1fr);",
                    "  gap: 2px;",
                    "  margin: 15px 0;",
                    "}",
                    "",
                    ".grid-cell {",
                    "  aspect-ratio: 1;",
                    "  background: #3a3a3a;",
                    "  border-radius: 3px;",
                    "  cursor: pointer;",
                    "  transition: all 0.2s;",
                    "}",
                    "",
                    ".grid-cell.active {",
                    "  background: #00ff9d;",
                    "  box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);",
                    "}",
                    "",
                    ".visualizer-container {",
                    "  position: relative;",
                    "  background: #2a2a2a;",
                    "  border-radius: 10px;",
                    "  overflow: hidden;",
                    "}",
                    "",
                    "#visualizer {",
                    "  width: 100%;",
                    "  height: 100%;",
                    "}",
                    "",
                    ".screenshot {",
                    "  position: absolute;",
                    "  bottom: 15px;",
                    "  right: 15px;",
                    "  background: rgba(255, 255, 255, 0.1);",
                    "  border: none;",
                    "  border-radius: 50%;",
                    "  width: 40px;",
                    "  height: 40px;",
                    "  cursor: pointer;",
                    "  transition: all 0.3s;",
                    "}",
                    "",
                    ".screenshot:hover {",
                    "  background: rgba(255, 255, 255, 0.2);",
                    "  transform: scale(1.1);",
                    "}"
                ],
                "audioEngine": [
                    "class BytebeatEngine {",
                    "  constructor() {",
                    "    this.audioCtx = new AudioContext();",
                    "    this.setupModules();",
                    "  }",
                    "",
                    "  setupModules() {",
                    "    this.oscillator = this.audioCtx.createOscillator();",
                    "    this.gain = this.audioCtx.createGain();",
                    "    this.filter = this.audioCtx.createBiquadFilter();",
                    "    this.delay = this.audioCtx.createDelay();",
                    "    this.delayFeedback = this.audioCtx.createGain();",
                    "",
                    "    // Connect modules",
                    "    this.oscillator.connect(this.filter);",
                    "    this.filter.connect(this.delay);",
                    "    this.delay.connect(this.delayFeedback);",
                    "    this.delayFeedback.connect(this.delay);",
                    "    this.delay.connect(this.gain);",
                    "    this.gain.connect(this.audioCtx.destination);",
                    "  }",
                    "",
                    "  updateOscillator(type, frequency) {",
                    "    this.oscillator.type = type;",
                    "    this.oscillator.frequency.setValueAtTime(",
                    "      frequency,",
                    "      this.audioCtx.currentTime",
                    "    );",
                    "  }",
                    "",
                    "  updateFilter(frequency, resonance) {",
                    "    this.filter.frequency.setValueAtTime(",
                    "      frequency,",
                    "      this.audioCtx.currentTime",
                    "    );",
                    "    this.filter.Q.setValueAtTime(",
                    "      resonance,",
                    "      this.audioCtx.currentTime",
                    "    );",
                    "  }",
                    "",
                    "  updateDelay(time, feedback) {",
                    "    this.delay.delayTime.setValueAtTime(",
                    "      time,",
                    "      this.audioCtx.currentTime",
                    "    );",
                    "    this.delayFeedback.gain.setValueAtTime(",
                    "      feedback,",
                    "      this.audioCtx.currentTime",
                    "    );",
                    "  }",
                    "}"
                ],
                "sequencer": [
                    "class Sequencer {",
                    "  constructor(gridSize = 16) {",
                    "    this.grid = Array(gridSize).fill(false);",
                    "    this.step = 0;",
                    "    this.bpm = 120;",
                    "  }",
                    "",
                    "  start() {",
                    "    const stepTime = (60 / this.bpm) / 4;",
                    "    this.interval = setInterval(() => {",
                    "      if (this.grid[this.step]) {",
                    "        this.trigger();",
                    "      }",
                    "      this.step = (this.step + 1) % this.grid.length;",
                    "      this.updateVisuals();",
                    "    }, stepTime * 1000);",
                    "  }",
                    "",
                    "  quantize() {",
                    "    const threshold = 0.5;",
                    "    this.grid = this.grid.map(cell =>",
                    "      Math.random() > threshold ? true : false",
                    "    );",
                    "    this.updateVisuals();",
                    "  }",
                    "",
                    "  updateVisuals() {",
                    "    document.querySelectorAll('.grid-cell').forEach((cell, i) => {",
                    "      cell.classList.toggle('active', this.grid[i]);",
                    "      cell.classList.toggle('current', i === this.step);",
                    "    });",
                    "  }",
                    "}"
                ],
                "visualizer": [
                    "class Visualizer {",
                    "  constructor(canvas) {",
                    "    this.canvas = canvas;",
                    "    this.ctx = canvas.getContext('2d');",
                    "    this.analyser = audioCtx.createAnalyser();",
                    "    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);",
                    "  }",
                    "",
                    "  draw() {",
                    "    this.analyser.getByteFrequencyData(this.dataArray);",
                    "    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);",
                    "",
                    "    const barWidth = this.canvas.width / this.dataArray.length;",
                    "    const heightScale = this.canvas.height / 255;",
                    "",
                    "    this.ctx.fillStyle = '#00ff9d';",
                    "    this.dataArray.forEach((value, i) => {",
                    "      const x = i * barWidth;",
                    "      const height = value * heightScale;",
                    "      this.ctx.fillRect(",
                    "        x,",
                    "        this.canvas.height - height,",
                    "        barWidth - 1,",
                    "        height",
                    "      );",
                    "    });",
                    "",
                    "    requestAnimationFrame(() => this.draw());",
                    "  }",
                    "",
                    "  takeScreenshot() {",
                    "    const link = document.createElement('a');",
                    "    link.download = 'bytebeat-pattern.png';",
                    "    link.href = this.canvas.toDataURL();",
                    "    link.click();",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "gameboy-hardware-1",
        "pattern_name": "GameBoy Hardware CSS",
        "type": "visual_design",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Pure CSS/HTML implementation of a GameBoy-style hardware device",
            "metadata": {
                "design_type": "hardware_mockup",
                "implementation": "pure_css",
                "features": [
                    "realistic_hardware",
                    "device_layout",
                    "physical_buttons",
                    "screen_display"
                ],
                "strengths": [
                    "authentic appearance",
                    "no images required",
                    "scalable design",
                    "reusable components"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='gameboy'>",
                    "  <div class='screen-area'>",
                    "    <div class='power-light'></div>",
                    "    <div class='screen'>",
                    "      <div class='screen-frame'>",
                    "        <div class='screen-content'></div>",
                    "      </div>",
                    "      <div class='brand'>GAME BOY</div>",
                    "      <div class='model'>NINTENDO</div>",
                    "    </div>",
                    "  </div>",
                    "  ",
                    "  <div class='controls'>",
                    "    <div class='d-pad'>",
                    "      <div class='d-up'></div>",
                    "      <div class='d-right'></div>",
                    "      <div class='d-down'></div>",
                    "      <div class='d-left'></div>",
                    "      <div class='d-middle'></div>",
                    "    </div>",
                    "    ",
                    "    <div class='ab-buttons'>",
                    "      <div class='btn-b'>B</div>",
                    "      <div class='btn-a'>A</div>",
                    "    </div>",
                    "    ",
                    "    <div class='start-select'>",
                    "      <div class='btn-select'>SELECT</div>",
                    "      <div class='btn-start'>START</div>",
                    "    </div>",
                    "  </div>",
                    "  ",
                    "  <div class='speaker'>",
                    "    <div class='speaker-lines'></div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".gameboy {",
                    "  width: 400px;",
                    "  height: 650px;",
                    "  background: #ddd;",
                    "  border-radius: 15px 15px 50px 15px;",
                    "  padding: 40px 20px;",
                    "  box-shadow: ",
                    "    -5px -5px 10px rgba(255, 255, 255, 0.8),",
                    "    5px 5px 10px rgba(0, 0, 0, 0.2),",
                    "    inset -2px -2px 5px rgba(0, 0, 0, 0.1);",
                    "}",
                    "",
                    ".screen-area {",
                    "  background: #777;",
                    "  padding: 30px;",
                    "  border-radius: 10px;",
                    "  margin-bottom: 40px;",
                    "}",
                    "",
                    ".power-light {",
                    "  width: 10px;",
                    "  height: 10px;",
                    "  background: #f00;",
                    "  border-radius: 50%;",
                    "  position: absolute;",
                    "  top: 50px;",
                    "  left: 50px;",
                    "  box-shadow: 0 0 5px #f00;",
                    "}",
                    "",
                    ".screen {",
                    "  background: #2c3e50;",
                    "  height: 220px;",
                    "  border-radius: 5px;",
                    "  position: relative;",
                    "}",
                    "",
                    ".screen-frame {",
                    "  position: absolute;",
                    "  top: 20px;",
                    "  left: 20px;",
                    "  right: 20px;",
                    "  bottom: 40px;",
                    "  background: #9ba5b0;",
                    "  border: 2px solid #34495e;",
                    "}",
                    "",
                    ".screen-content {",
                    "  position: absolute;",
                    "  top: 2px;",
                    "  left: 2px;",
                    "  right: 2px;",
                    "  bottom: 2px;",
                    "  background: #1f2d3d;",
                    "}",
                    "",
                    ".brand {",
                    "  position: absolute;",
                    "  bottom: 10px;",
                    "  width: 100%;",
                    "  text-align: center;",
                    "  color: #fff;",
                    "  font-family: 'Helvetica', sans-serif;",
                    "  font-size: 12px;",
                    "  letter-spacing: 2px;",
                    "}",
                    "",
                    ".d-pad {",
                    "  position: relative;",
                    "  width: 120px;",
                    "  height: 120px;",
                    "  margin: 20px;",
                    "}",
                    "",
                    ".d-pad > div {",
                    "  position: absolute;",
                    "  background: #444;",
                    "  box-shadow: ",
                    "    inset -2px -2px 5px rgba(0, 0, 0, 0.5),",
                    "    1px 1px 3px rgba(255, 255, 255, 0.3);",
                    "}",
                    "",
                    ".d-up, .d-down {",
                    "  width: 40px;",
                    "  height: 40px;",
                    "  left: 40px;",
                    "}",
                    "",
                    ".d-left, .d-right {",
                    "  width: 40px;",
                    "  height: 40px;",
                    "  top: 40px;",
                    "}",
                    "",
                    ".d-up { top: 0; }",
                    ".d-right { right: 0; }",
                    ".d-down { bottom: 0; }",
                    ".d-left { left: 0; }",
                    "",
                    ".d-middle {",
                    "  width: 40px;",
                    "  height: 40px;",
                    "  top: 40px;",
                    "  left: 40px;",
                    "  background: #555 !important;",
                    "}",
                    "",
                    ".ab-buttons {",
                    "  position: absolute;",
                    "  right: 40px;",
                    "  top: 100px;",
                    "  transform: rotate(-25deg);",
                    "}",
                    "",
                    ".btn-a, .btn-b {",
                    "  width: 50px;",
                    "  height: 50px;",
                    "  background: #a00;",
                    "  border-radius: 50%;",
                    "  margin: 10px;",
                    "  color: #600;",
                    "  text-align: center;",
                    "  line-height: 50px;",
                    "  font-weight: bold;",
                    "  box-shadow:",
                    "    inset -2px -2px 5px rgba(0, 0, 0, 0.5),",
                    "    1px 1px 3px rgba(255, 255, 255, 0.3);",
                    "}",
                    "",
                    ".start-select {",
                    "  position: absolute;",
                    "  bottom: 80px;",
                    "  left: 50%;",
                    "  transform: translateX(-50%);",
                    "  display: flex;",
                    "  gap: 20px;",
                    "}",
                    "",
                    ".btn-start, .btn-select {",
                    "  width: 60px;",
                    "  height: 20px;",
                    "  background: #555;",
                    "  border-radius: 10px;",
                    "  transform: rotate(-25deg);",
                    "  font-size: 8px;",
                    "  color: #333;",
                    "  text-align: center;",
                    "  line-height: 20px;",
                    "  box-shadow:",
                    "    inset -1px -1px 3px rgba(0, 0, 0, 0.5),",
                    "    1px 1px 2px rgba(255, 255, 255, 0.3);",
                    "}",
                    "",
                    ".speaker {",
                    "  position: absolute;",
                    "  bottom: 30px;",
                    "  right: 30px;",
                    "  width: 80px;",
                    "  height: 80px;",
                    "}",
                    "",
                    ".speaker-lines {",
                    "  width: 100%;",
                    "  height: 100%;",
                    "  background: repeating-linear-gradient(",
                    "    45deg,",
                    "    #666,",
                    "    #666 2px,",
                    "    #777 2px,",
                    "    #777 4px",
                    "  );",
                    "  border-radius: 3px;",
                    "}"
                ]
            }
        }
    },
    {
        "id": "webdaw-sequencer-1",
        "pattern_name": "WebDAW Sequencer",
        "type": "audio_application",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Modern drum pad sequencer with WebDAW integration for beat creation",
            "metadata": {
                "app_type": "sequencer",
                "interaction_type": "grid_based",
                "features": [
                    "tempo_control",
                    "drum_pads",
                    "pattern_sequencing",
                    "webdaw_integration",
                    "real_time_playback"
                ],
                "strengths": [
                    "intuitive grid interface",
                    "responsive audio",
                    "professional features",
                    "modern design",
                    "open source integration"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='sequencer'>",
                    "  <div class='controls'>",
                    "    <div class='transport'>",
                    "      <button class='play'>▶️</button>",
                    "      <button class='stop'>⏹️</button>",
                    "      <div class='tempo'>",
                    "        <label>BPM</label>",
                    "        <input type='number' value='120' min='60' max='200'>",
                    "      </div>",
                    "    </div>",
                    "    <div class='track-controls'>",
                    "      <button class='add-track'>+ Add Track</button>",
                    "      <select class='quantize'>",
                    "        <option value='4'>1/4</option>",
                    "        <option value='8'>1/8</option>",
                    "        <option value='16'>1/16</option>",
                    "      </select>",
                    "    </div>",
                    "  </div>",
                    "  ",
                    "  <div class='grid-container'>",
                    "    <div class='track-labels'>",
                    "      <div class='track'>Kick</div>",
                    "      <div class='track'>Snare</div>",
                    "      <div class='track'>Hi-Hat</div>",
                    "      <div class='track'>Clap</div>",
                    "    </div>",
                    "    <div class='grid'></div>",
                    "  </div>",
                    "  ",
                    "  <div class='drum-pads'>",
                    "    <div class='pad' data-sound='kick'>KICK</div>",
                    "    <div class='pad' data-sound='snare'>SNARE</div>",
                    "    <div class='pad' data-sound='hihat'>HAT</div>",
                    "    <div class='pad' data-sound='clap'>CLAP</div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".sequencer {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 20px;",
                    "  padding: 20px;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "  font-family: 'Inter', system-ui;",
                    "}",
                    "",
                    ".controls {",
                    "  display: flex;",
                    "  justify-content: space-between;",
                    "  align-items: center;",
                    "  padding: 10px;",
                    "  background: #2a2a2a;",
                    "  border-radius: 8px;",
                    "}",
                    "",
                    ".transport {",
                    "  display: flex;",
                    "  gap: 10px;",
                    "  align-items: center;",
                    "}",
                    "",
                    ".grid-container {",
                    "  display: grid;",
                    "  grid-template-columns: auto 1fr;",
                    "  gap: 10px;",
                    "}",
                    "",
                    ".grid {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(16, 1fr);",
                    "  gap: 2px;",
                    "  background: #2a2a2a;",
                    "  padding: 10px;",
                    "  border-radius: 8px;",
                    "}",
                    "",
                    ".cell {",
                    "  aspect-ratio: 1;",
                    "  background: #3a3a3a;",
                    "  border-radius: 4px;",
                    "  cursor: pointer;",
                    "  transition: all 0.1s;",
                    "}",
                    "",
                    ".cell.active {",
                    "  background: #00ff9d;",
                    "  box-shadow: 0 0 10px rgba(0, 255, 157, 0.5);",
                    "}",
                    "",
                    ".cell.playing {",
                    "  border: 2px solid #fff;",
                    "}",
                    "",
                    ".drum-pads {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(4, 1fr);",
                    "  gap: 10px;",
                    "  padding: 20px;",
                    "}",
                    "",
                    ".pad {",
                    "  aspect-ratio: 1;",
                    "  background: linear-gradient(145deg, #2a2a2a, #3a3a3a);",
                    "  border-radius: 8px;",
                    "  display: flex;",
                    "  align-items: center;",
                    "  justify-content: center;",
                    "  font-weight: bold;",
                    "  cursor: pointer;",
                    "  user-select: none;",
                    "  transition: all 0.1s;",
                    "}",
                    "",
                    ".pad:active {",
                    "  transform: scale(0.95);",
                    "  background: linear-gradient(145deg, #3a3a3a, #2a2a2a);",
                    "}"
                ],
                "webdawSetup": [
                    "class WebDAWSequencer {",
                    "  constructor() {",
                    "    this.audioContext = new AudioContext();",
                    "    this.bpm = 120;",
                    "    this.playing = false;",
                    "    this.currentStep = 0;",
                    "    this.tracks = [];",
                    "    this.loadSamples();",
                    "  }",
                    "",
                    "  async loadSamples() {",
                    "    const samples = {",
                    "      kick: '/samples/kick.wav',",
                    "      snare: '/samples/snare.wav',",
                    "      hihat: '/samples/hihat.wav',",
                    "      clap: '/samples/clap.wav'",
                    "    };",
                    "",
                    "    this.buffers = {};",
                    "    for (const [name, url] of Object.entries(samples)) {",
                    "      const response = await fetch(url);",
                    "      const arrayBuffer = await response.arrayBuffer();",
                    "      this.buffers[name] = await this.audioContext.decodeAudioData(arrayBuffer);",
                    "    }",
                    "  }",
                    "",
                    "  playSample(name) {",
                    "    const source = this.audioContext.createBufferSource();",
                    "    source.buffer = this.buffers[name];",
                    "",
                    "    const gainNode = this.audioContext.createGain();",
                    "    gainNode.gain.value = 0.8;",
                    "",
                    "    source.connect(gainNode).connect(this.audioContext.destination);",
                    "    source.start();",
                    "  }",
                    "",
                    "  startSequencer() {",
                    "    if (this.playing) return;",
                    "    this.playing = true;",
                    "    this.tick();",
                    "  }",
                    "",
                    "  tick() {",
                    "    if (!this.playing) return;",
                    "",
                    "    const stepTime = (60 / this.bpm) / 4;",
                    "    const nextTickTime = this.audioContext.currentTime + stepTime;",
                    "",
                    "    // Play active samples for current step",
                    "    this.tracks.forEach(track => {",
                    "      if (track.pattern[this.currentStep]) {",
                    "        this.playSample(track.sound);",
                    "      }",
                    "    });",
                    "",
                    "    // Update UI",
                    "    this.updateGridUI();",
                    "",
                    "    // Schedule next tick",
                    "    this.currentStep = (this.currentStep + 1) % 16;",
                    "    setTimeout(() => this.tick(), stepTime * 1000);",
                    "  }",
                    "",
                    "  updateGridUI() {",
                    "    document.querySelectorAll('.cell').forEach(cell => {",
                    "      cell.classList.toggle('playing', ",
                    "        parseInt(cell.dataset.step) === this.currentStep);",
                    "    });",
                    "  }",
                    "",
                    "  setTempo(bpm) {",
                    "    this.bpm = Math.max(60, Math.min(200, bpm));",
                    "  }",
                    "",
                    "  toggleCell(trackIndex, step) {",
                    "    this.tracks[trackIndex].pattern[step] = ",
                    "      !this.tracks[trackIndex].pattern[step];",
                    "    this.updateGridUI();",
                    "  }",
                    "}"
                ],
                "eventHandlers": [
                    "// Initialize sequencer",
                    "const sequencer = new WebDAWSequencer();",
                    "",
                    "// Drum pad handlers",
                    "document.querySelectorAll('.pad').forEach(pad => {",
                    "  pad.addEventListener('mousedown', () => {",
                    "    pad.classList.add('active');",
                    "    sequencer.playSample(pad.dataset.sound);",
                    "  });",
                    "",
                    "  pad.addEventListener('mouseup', () => {",
                    "    pad.classList.remove('active');",
                    "  });",
                    "});",
                    "",
                    "// Transport controls",
                    "document.querySelector('.play').addEventListener('click', () => {",
                    "  sequencer.startSequencer();",
                    "});",
                    "",
                    "document.querySelector('.stop').addEventListener('click', () => {",
                    "  sequencer.playing = false;",
                    "});",
                    "",
                    "// Tempo control",
                    "document.querySelector('.tempo input').addEventListener('change', e => {",
                    "  sequencer.setTempo(parseInt(e.target.value));",
                    "});",
                    "",
                    "// Track controls",
                    "document.querySelector('.add-track').addEventListener('click', () => {",
                    "  sequencer.addTrack();",
                    "});",
                    "",
                    "// Quantization",
                    "document.querySelector('.quantize').addEventListener('change', e => {",
                    "  sequencer.quantize(parseInt(e.target.value));",
                    "});"
                ]
            }
        }
    },
    {
        "id": "pixel-art-generator-1",
        "pattern_name": "Procedural Pixel Art Generator",
        "type": "generator_app",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Customizable procedural pixel art generator with intuitive layout",
            "metadata": {
                "app_type": "generator",
                "interaction_type": "multi_control",
                "features": [
                    "procedural_generation",
                    "customization_controls",
                    "instant_preview",
                    "save_functionality",
                    "random_generation"
                ],
                "strengths": [
                    "intuitive layout",
                    "extensive customization",
                    "practical controls",
                    "efficient workflow"
                ],
                "layout_regions": [
                    "center_preview",
                    "bottom_controls",
                    "bottom_left_random",
                    "bottom_right_save"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='generator-app'>",
                    "  <div class='preview-area'>",
                    "    <canvas id='pixelCanvas'></canvas>",
                    "  </div>",
                    "",
                    "  <div class='controls-area'>",
                    "    <div class='left-controls'>",
                    "      <button class='random-btn'>🎲 Random</button>",
                    "    </div>",
                    "",
                    "    <div class='center-controls'>",
                    "      <div class='slider-group'>",
                    "        <label>Size</label>",
                    "        <input type='range' id='sizeSlider' min='8' max='64' value='32'>",
                    "      </div>",
                    "      <div class='slider-group'>",
                    "        <label>Complexity</label>",
                    "        <input type='range' id='complexitySlider' min='1' max='10' value='5'>",
                    "      </div>",
                    "      <div class='slider-group'>",
                    "        <label>Symmetry</label>",
                    "        <input type='range' id='symmetrySlider' min='0' max='4' value='1'>",
                    "      </div>",
                    "      <div class='slider-group'>",
                    "        <label>Color Variance</label>",
                    "        <input type='range' id='colorVarianceSlider' min='0' max='100' value='50'>",
                    "      </div>",
                    "    </div>",
                    "",
                    "    <div class='right-controls'>",
                    "      <button class='save-btn'>💾 Save</button>",
                    "    </div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".generator-app {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  height: 100vh;",
                    "  background: #f5f5f5;",
                    "  padding: 20px;",
                    "  gap: 20px;",
                    "}",
                    "",
                    ".preview-area {",
                    "  flex: 1;",
                    "  display: flex;",
                    "  align-items: center;",
                    "  justify-content: center;",
                    "  background: #fff;",
                    "  border-radius: 8px;",
                    "  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);",
                    "}",
                    "",
                    "#pixelCanvas {",
                    "  image-rendering: pixelated;",
                    "  max-width: 90%;",
                    "  max-height: 90%;",
                    "}",
                    "",
                    ".controls-area {",
                    "  display: grid;",
                    "  grid-template-columns: auto 1fr auto;",
                    "  gap: 20px;",
                    "  padding: 20px;",
                    "  background: #fff;",
                    "  border-radius: 8px;",
                    "  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);",
                    "}",
                    "",
                    ".center-controls {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));",
                    "  gap: 20px;",
                    "}",
                    "",
                    ".slider-group {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 5px;",
                    "}",
                    "",
                    "input[type='range'] {",
                    "  width: 100%;",
                    "}",
                    "",
                    "button {",
                    "  padding: 10px 20px;",
                    "  border: none;",
                    "  border-radius: 4px;",
                    "  cursor: pointer;",
                    "  transition: all 0.2s;",
                    "}",
                    "",
                    ".random-btn {",
                    "  background: #4CAF50;",
                    "  color: white;",
                    "}",
                    "",
                    ".save-btn {",
                    "  background: #2196F3;",
                    "  color: white;",
                    "}"
                ],
                "generatorLogic": [
                    "class PixelArtGenerator {",
                    "  constructor(canvas, size = 32) {",
                    "    this.canvas = canvas;",
                    "    this.ctx = canvas.getContext('2d');",
                    "    this.size = size;",
                    "    this.setupCanvas();",
                    "  }",
                    "",
                    "  setupCanvas() {",
                    "    this.canvas.width = this.size;",
                    "    this.canvas.height = this.size;",
                    "    this.ctx.imageSmoothingEnabled = false;",
                    "  }",
                    "",
                    "  generate(params) {",
                    "    const {",
                    "      complexity,",
                    "      symmetry,",
                    "      colorVariance",
                    "    } = params;",
                    "",
                    "    // Clear canvas",
                    "    this.ctx.clearRect(0, 0, this.size, this.size);",
                    "",
                    "    // Generate base palette",
                    "    const palette = this.generatePalette(colorVariance);",
                    "",
                    "    // Generate base noise",
                    "    const noise = this.generateNoise(complexity);",
                    "",
                    "    // Apply symmetry",
                    "    const symmetricNoise = this.applySymmetry(noise, symmetry);",
                    "",
                    "    // Render pixels",
                    "    this.renderPixels(symmetricNoise, palette);",
                    "  }",
                    "",
                    "  generatePalette(variance) {",
                    "    const baseHue = Math.random() * 360;",
                    "    const palette = [];",
                    "    const colorCount = 4 + Math.floor(variance / 20);",
                    "",
                    "    for (let i = 0; i < colorCount; i++) {",
                    "      const hue = (baseHue + (360 / colorCount * i)) % 360;",
                    "      const sat = 70 + Math.random() * 30;",
                    "      const light = 40 + Math.random() * 40;",
                    "      palette.push(`hsl(${hue}, ${sat}%, ${light}%)`);",
                    "    }",
                    "",
                    "    return palette;",
                    "  }",
                    "",
                    "  generateNoise(complexity) {",
                    "    const noise = new Array(this.size * this.size).fill(0);",
                    "    const features = Math.max(1, Math.floor(complexity * 3));",
                    "",
                    "    for (let f = 0; f < features; f++) {",
                    "      const fx = Math.random() * this.size;",
                    "      const fy = Math.random() * this.size;",
                    "      const radius = Math.random() * (this.size / 2) + (this.size / 4);",
                    "",
                    "      for (let y = 0; y < this.size; y++) {",
                    "        for (let x = 0; x < this.size; x++) {",
                    "          const dx = x - fx;",
                    "          const dy = y - fy;",
                    "          const dist = Math.sqrt(dx * dx + dy * dy);",
                    "          const value = Math.max(0, 1 - (dist / radius));",
                    "          noise[y * this.size + x] += value;",
                    "        }",
                    "      }",
                    "    }",
                    "",
                    "    return noise;",
                    "  }",
                    "",
                    "  applySymmetry(noise, symmetryLevel) {",
                    "    const result = [...noise];",
                    "    const halfSize = Math.floor(this.size / 2);",
                    "",
                    "    switch(symmetryLevel) {",
                    "      case 1: // Horizontal",
                    "        for (let y = 0; y < this.size; y++) {",
                    "          for (let x = 0; x < halfSize; x++) {",
                    "            result[y * this.size + (this.size - 1 - x)] =",
                    "              result[y * this.size + x];",
                    "          }",
                    "        }",
                    "        break;",
                    "",
                    "      case 2: // Vertical",
                    "        for (let y = 0; y < halfSize; y++) {",
                    "          for (let x = 0; x < this.size; x++) {",
                    "            result[(this.size - 1 - y) * this.size + x] =",
                    "              result[y * this.size + x];",
                    "          }",
                    "        }",
                    "        break;",
                    "",
                    "      case 3: // Both",
                    "        // Apply horizontal then vertical",
                    "        this.applySymmetry(",
                    "          this.applySymmetry(noise, 1),",
                    "          2",
                    "        );",
                    "        break;",
                    "",
                    "      case 4: // Radial",
                    "        const center = { x: halfSize, y: halfSize };",
                    "        for (let y = 0; y < this.size; y++) {",
                    "          for (let x = 0; x < this.size; x++) {",
                    "            const angle = Math.atan2(y - center.y, x - center.x);",
                    "            const dist = Math.sqrt(",
                    "              Math.pow(x - center.x, 2) +",
                    "              Math.pow(y - center.y, 2)",
                    "            );",
                    "            const sx = Math.cos(angle) * dist + center.x;",
                    "            const sy = Math.sin(angle) * dist + center.y;",
                    "            result[y * this.size + x] = noise[",
                    "              Math.floor(sy) * this.size + Math.floor(sx)",
                    "            ];",
                    "          }",
                    "        }",
                    "        break;",
                    "    }",
                    "",
                    "    return result;",
                    "  }",
                    "",
                    "  renderPixels(noise, palette) {",
                    "    const maxNoise = Math.max(...noise);",
                    "    const step = maxNoise / palette.length;",
                    "",
                    "    for (let y = 0; y < this.size; y++) {",
                    "      for (let x = 0; x < this.size; x++) {",
                    "        const value = noise[y * this.size + x];",
                    "        const colorIndex = Math.min(",
                    "          palette.length - 1,",
                    "          Math.floor(value / step)",
                    "        );",
                    "        this.ctx.fillStyle = palette[colorIndex];",
                    "        this.ctx.fillRect(x, y, 1, 1);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  saveImage() {",
                    "    const link = document.createElement('a');",
                    "    link.download = 'pixel-art.png';",
                    "    link.href = this.canvas.toDataURL();",
                    "    link.click();",
                    "  }",
                    "}"
                ],
                "eventHandlers": [
                    "const generator = new PixelArtGenerator(",
                    "  document.getElementById('pixelCanvas')",
                    ");",
                    "",
                    "function updateArt() {",
                    "  generator.generate({",
                    "    complexity: complexitySlider.value,",
                    "    symmetry: parseInt(symmetrySlider.value),",
                    "    colorVariance: parseInt(colorVarianceSlider.value)",
                    "  });",
                    "}",
                    "",
                    "document.querySelector('.random-btn')",
                    "  .addEventListener('click', updateArt);",
                    "",
                    "document.querySelector('.save-btn')",
                    "  .addEventListener('click', () => generator.saveImage());",
                    "",
                    "// Update on slider changes",
                    "document.querySelectorAll('input[type=\"range\"]')",
                    "  .forEach(slider => {",
                    "    slider.addEventListener('input', updateArt);",
                    "  });"
                ]
            }
        }
    },
    {
        "id": "soundfont-piano-1",
        "pattern_name": "Soundfont Virtual Piano",
        "type": "audio_instrument",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Full-featured virtual piano with MIDI keyboard support and extensive soundfont library",
            "metadata": {
                "app_type": "virtual_instrument",
                "interaction_type": "keyboard_input",
                "features": [
                    "midi_support",
                    "multiple_instruments",
                    "keyboard_mapping",
                    "audio_filters",
                    "real_time_playback"
                ],
                "strengths": [
                    "extensive instrument library",
                    "responsive playback",
                    "professional audio quality",
                    "intuitive controls",
                    "open source soundfonts"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='piano-app'>",
                    "  <div class='controls'>",
                    "    <select id='instrument-select'>",
                    "      <option value='acoustic_grand_piano'>Grand Piano</option>",
                    "      <option value='acoustic_guitar_nylon'>Acoustic Guitar</option>",
                    "      <option value='violin'>Violin</option>",
                    "      <!-- More instruments... -->",
                    "    </select>",
                    "",
                    "    <div class='effects'>",
                    "      <div class='effect-group'>",
                    "        <label>Reverb</label>",
                    "        <input type='range' id='reverb' min='0' max='1' step='0.1' value='0.3'>",
                    "      </div>",
                    "      <div class='effect-group'>",
                    "        <label>Release</label>",
                    "        <input type='range' id='release' min='0' max='2' step='0.1' value='0.5'>",
                    "      </div>",
                    "    </div>",
                    "  </div>",
                    "",
                    "  <div class='keyboard'>",
                    "    <!-- Piano keys are generated dynamically -->",
                    "  </div>",
                    "",
                    "  <div class='info'>",
                    "    <p>Use your computer keyboard to play! Keys A-K for white notes, W-U for black notes.</p>",
                    "    <p>Or connect a MIDI keyboard for full control.</p>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".piano-app {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 20px;",
                    "  padding: 20px;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "  font-family: 'Inter', system-ui;",
                    "}",
                    "",
                    ".controls {",
                    "  display: flex;",
                    "  gap: 20px;",
                    "  align-items: center;",
                    "  padding: 15px;",
                    "  background: #2a2a2a;",
                    "  border-radius: 8px;",
                    "}",
                    "",
                    "#instrument-select {",
                    "  padding: 8px;",
                    "  background: #3a3a3a;",
                    "  color: #fff;",
                    "  border: none;",
                    "  border-radius: 4px;",
                    "}",
                    "",
                    ".effects {",
                    "  display: flex;",
                    "  gap: 15px;",
                    "}",
                    "",
                    ".effect-group {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 5px;",
                    "}",
                    "",
                    ".keyboard {",
                    "  display: flex;",
                    "  justify-content: center;",
                    "  height: 200px;",
                    "  position: relative;",
                    "}",
                    "",
                    ".key {",
                    "  position: relative;",
                    "  border: 1px solid #000;",
                    "  transition: all 0.1s;",
                    "}",
                    "",
                    ".key.white {",
                    "  width: 40px;",
                    "  height: 100%;",
                    "  background: #fff;",
                    "  z-index: 1;",
                    "}",
                    "",
                    ".key.black {",
                    "  width: 25px;",
                    "  height: 60%;",
                    "  background: #000;",
                    "  margin: 0 -12.5px;",
                    "  z-index: 2;",
                    "}",
                    "",
                    ".key.active {",
                    "  background: #4CAF50;",
                    "  transform: translateY(2px);",
                    "}"
                ],
                "soundfontSetup": [
                    "class SoundfontPiano {",
                    "  constructor() {",
                    "    this.audioContext = new AudioContext();",
                    "    this.masterGain = this.audioContext.createGain();",
                    "    this.reverb = this.createReverb();",
                    "    this.activeNotes = new Map();",
                    "    this.setupAudioChain();",
                    "    this.loadInstrument('acoustic_grand_piano');",
                    "  }",
                    "",
                    "  async loadInstrument(name) {",
                    "    const soundfontUrl = `https://gleitz.github.io/midi-js-soundfonts/FluidR3_GM/${name}-mp3.js`;",
                    "    const response = await fetch(soundfontUrl);",
                    "    const soundfont = await response.json();",
                    "",
                    "    this.buffers = {};",
                    "    for (const [note, data] of Object.entries(soundfont)) {",
                    "      const audioData = atob(data.split(',')[1]);",
                    "      const arrayBuffer = new ArrayBuffer(audioData.length);",
                    "      const view = new Uint8Array(arrayBuffer);",
                    "      for (let i = 0; i < audioData.length; i++) {",
                    "        view[i] = audioData.charCodeAt(i);",
                    "      }",
                    "      this.buffers[note] = await this.audioContext.decodeAudioData(arrayBuffer);",
                    "    }",
                    "  }",
                    "",
                    "  createReverb() {",
                    "    const convolver = this.audioContext.createConvolver();",
                    "    // Load impulse response...",
                    "    return convolver;",
                    "  }",
                    "",
                    "  setupAudioChain() {",
                    "    this.masterGain.connect(this.reverb);",
                    "    this.reverb.connect(this.audioContext.destination);",
                    "  }",
                    "",
                    "  playNote(note, velocity = 1) {",
                    "    if (this.activeNotes.has(note)) {",
                    "      this.stopNote(note);",
                    "    }",
                    "",
                    "    const source = this.audioContext.createBufferSource();",
                    "    const gain = this.audioContext.createGain();",
                    "    source.buffer = this.buffers[note];",
                    "",
                    "    // Apply velocity",
                    "    gain.gain.value = velocity;",
                    "",
                    "    source.connect(gain);",
                    "    gain.connect(this.masterGain);",
                    "    source.start();",
                    "",
                    "    this.activeNotes.set(note, { source, gain });",
                    "  }",
                    "",
                    "  stopNote(note) {",
                    "    if (this.activeNotes.has(note)) {",
                    "      const { gain } = this.activeNotes.get(note);",
                    "      const release = parseFloat(document.getElementById('release').value);",
                    "",
                    "      gain.gain.setValueAtTime(gain.gain.value, this.audioContext.currentTime);",
                    "      gain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + release);",
                    "",
                    "      this.activeNotes.delete(note);",
                    "    }",
                    "  }",
                    "",
                    "  setReverb(amount) {",
                    "    this.reverb.mix = amount;",
                    "  }",
                    "}"
                ],
                "keyboardHandling": [
                    "const keyMap = {",
                    "  'a': 60, // Middle C",
                    "  'w': 61,",
                    "  's': 62,",
                    "  'e': 63,",
                    "  'd': 64,",
                    "  'f': 65,",
                    "  't': 66,",
                    "  'g': 67,",
                    "  'y': 68,",
                    "  'h': 69,",
                    "  'u': 70,",
                    "  'j': 71,",
                    "  'k': 72",
                    "};",
                    "",
                    "document.addEventListener('keydown', e => {",
                    "  if (!e.repeat && keyMap[e.key]) {",
                    "    const note = keyMap[e.key];",
                    "    piano.playNote(note);",
                    "    document.querySelector(`[data-note='${note}']`).classList.add('active');",
                    "  }",
                    "});",
                    "",
                    "document.addEventListener('keyup', e => {",
                    "  if (keyMap[e.key]) {",
                    "    const note = keyMap[e.key];",
                    "    piano.stopNote(note);",
                    "    document.querySelector(`[data-note='${note}']`).classList.remove('active');",
                    "  }",
                    "});"
                ],
                "midiSupport": [
                    "if (navigator.requestMIDIAccess) {",
                    "  navigator.requestMIDIAccess().then(access => {",
                    "    for (const input of access.inputs.values()) {",
                    "      input.onmidimessage = ({ data }) => {",
                    "        const [command, note, velocity] = data;",
                    "",
                    "        if (command === 144 && velocity > 0) {",
                    "          // Note On",
                    "          piano.playNote(note, velocity / 127);",
                    "          document.querySelector(`[data-note='${note}']`)?.classList.add('active');",
                    "        } else if (command === 128 || (command === 144 && velocity === 0)) {",
                    "          // Note Off",
                    "          piano.stopNote(note);",
                    "          document.querySelector(`[data-note='${note}']`)?.classList.remove('active');",
                    "        }",
                    "      };",
                    "    }",
                    "  });",
                    "}"
                ]
            }
        }
    },
    {
        "id": "musical-spheres-1",
        "pattern_name": "Musical Spheres",
        "type": "audio_visual",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Interactive musical visualization with falling spheres that create rhythmic patterns",
            "metadata": {
                "visual_type": "particle_system",
                "interaction_type": "parameter_control",
                "features": [
                    "rhythmic_timing",
                    "particle_physics",
                    "musical_feedback",
                    "color_dynamics",
                    "user_controls"
                ],
                "strengths": [
                    "engaging visuals",
                    "musical interactivity",
                    "customizable experience",
                    "smooth animations"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='spheres-container'>",
                    "  <canvas id='sphereCanvas'></canvas>",
                    "  <div class='controls'>",
                    "    <div class='control-group'>",
                    "      <label>Sphere Count</label>",
                    "      <input type='range' id='sphereCount' min='1' max='50' value='10'>",
                    "    </div>",
                    "    <div class='control-group'>",
                    "      <label>Fall Speed</label>",
                    "      <input type='range' id='fallSpeed' min='1' max='10' value='5'>",
                    "    </div>",
                    "    <div class='control-group'>",
                    "      <label>Rhythm Interval</label>",
                    "      <input type='range' id='rhythmInterval' min='100' max='2000' value='500'>",
                    "    </div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".spheres-container {",
                    "  position: relative;",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "  background: #111;",
                    "  overflow: hidden;",
                    "}",
                    "",
                    "canvas {",
                    "  position: absolute;",
                    "  top: 0;",
                    "  left: 0;",
                    "  width: 100%;",
                    "  height: 100%;",
                    "}",
                    "",
                    ".controls {",
                    "  position: fixed;",
                    "  bottom: 20px;",
                    "  left: 50%;",
                    "  transform: translateX(-50%);",
                    "  display: flex;",
                    "  gap: 20px;",
                    "  padding: 15px;",
                    "  background: rgba(0, 0, 0, 0.7);",
                    "  border-radius: 10px;",
                    "  backdrop-filter: blur(10px);",
                    "}",
                    "",
                    ".control-group {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 5px;",
                    "  color: #fff;",
                    "}",
                    "",
                    "input[type='range'] {",
                    "  width: 150px;",
                    "  accent-color: #4CAF50;",
                    "}"
                ],
                "sphereSystem": [
                    "class Sphere {",
                    "  constructor(x, radius, color) {",
                    "    this.x = x;",
                    "    this.y = -radius;",
                    "    this.radius = radius;",
                    "    this.color = color;",
                    "    this.velocity = 0;",
                    "    this.acceleration = 0.2;",
                    "    this.damping = 0.8;",
                    "    this.active = true;",
                    "    this.lastBounce = 0;",
                    "  }",
                    "",
                    "  update(fallSpeed) {",
                    "    if (!this.active) return;",
                    "",
                    "    this.velocity += this.acceleration * fallSpeed;",
                    "    this.y += this.velocity;",
                    "",
                    "    // Ground collision",
                    "    if (this.y + this.radius > canvas.height) {",
                    "      this.y = canvas.height - this.radius;",
                    "      this.velocity *= -this.damping;",
                    "",
                    "      const now = performance.now();",
                    "      if (now - this.lastBounce > 200) {",
                    "        this.playNote();",
                    "        this.lastBounce = now;",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  draw(ctx) {",
                    "    ctx.beginPath();",
                    "    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);",
                    "    ctx.fillStyle = this.color;",
                    "    ctx.fill();",
                    "",
                    "    // Add glow effect",
                    "    ctx.shadowColor = this.color;",
                    "    ctx.shadowBlur = 20;",
                    "    ctx.fill();",
                    "    ctx.shadowBlur = 0;",
                    "  }",
                    "",
                    "  playNote() {",
                    "    const osc = audioCtx.createOscillator();",
                    "    const gain = audioCtx.createGain();",
                    "",
                    "    // Map x position to frequency",
                    "    const minFreq = 220; // A3",
                    "    const maxFreq = 880; // A5",
                    "    const freq = minFreq + (this.x / canvas.width) * (maxFreq - minFreq);",
                    "",
                    "    osc.frequency.value = freq;",
                    "    osc.type = 'sine';",
                    "",
                    "    gain.gain.setValueAtTime(0.5, audioCtx.currentTime);",
                    "    gain.gain.exponentialRampToValueAtTime(",
                    "      0.01,",
                    "      audioCtx.currentTime + 0.5",
                    "    );",
                    "",
                    "    osc.connect(gain);",
                    "    gain.connect(audioCtx.destination);",
                    "",
                    "    osc.start();",
                    "    osc.stop(audioCtx.currentTime + 0.5);",
                    "  }",
                    "}"
                ],
                "mainLoop": [
                    "const spheres = [];",
                    "const colors = [",
                    "  '#ff0055',",
                    "  '#00ff99',",
                    "  '#00ccff',",
                    "  '#ffaa00',",
                    "  '#aa00ff'",
                    "];",
                    "",
                    "function updateSpheres() {",
                    "  const count = parseInt(sphereCount.value);",
                    "  const speed = parseFloat(fallSpeed.value);",
                    "",
                    "  // Add/remove spheres as needed",
                    "  while (spheres.length < count) {",
                    "    const x = Math.random() * canvas.width;",
                    "    const radius = 15 + Math.random() * 15;",
                    "    const color = colors[Math.floor(Math.random() * colors.length)];",
                    "    spheres.push(new Sphere(x, radius, color));",
                    "  }",
                    "",
                    "  while (spheres.length > count) {",
                    "    spheres.pop();",
                    "  }",
                    "",
                    "  // Update and draw spheres",
                    "  ctx.clearRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  spheres.forEach(sphere => {",
                    "    sphere.update(speed);",
                    "    sphere.draw(ctx);",
                    "  });",
                    "",
                    "  requestAnimationFrame(updateSpheres);",
                    "}",
                    "",
                    "// Start animation",
                    "updateSpheres();"
                ],
                "eventHandlers": [
                    "// Initialize audio context on user interaction",
                    "document.addEventListener('click', () => {",
                    "  if (!audioCtx) {",
                    "    audioCtx = new (window.AudioContext || window.webkitAudioContext)();",
                    "  }",
                    "});",
                    "",
                    "// Handle window resize",
                    "window.addEventListener('resize', () => {",
                    "  canvas.width = window.innerWidth;",
                    "  canvas.height = window.innerHeight;",
                    "});",
                    "",
                    "// Update rhythm interval",
                    "rhythmInterval.addEventListener('input', e => {",
                    "  const interval = parseInt(e.target.value);",
                    "  spheres.forEach(sphere => {",
                    "    sphere.rhythmInterval = interval;",
                    "  });",
                    "});"
                ]
            }
        }
    },
    {
        "id": "gravity-field-1",
        "pattern_name": "Gravity Field Simulator",
        "type": "physics_interaction",
        "effectiveness_score": 0.95,
        "usage_count": 1,
        "content": {
            "context": "Interactive gravity field simulator with charge-and-release mechanics",
            "metadata": {
                "interaction_type": "hold_and_release",
                "physics_type": "particle_system",
                "features": [
                    "force_accumulation",
                    "particle_explosion",
                    "color_dynamics",
                    "physics_simulation"
                ],
                "strengths": [
                    "satisfying physics",
                    "intuitive interaction",
                    "visual feedback",
                    "emergent behavior"
                ]
            },
            "implementation": {
                "html": [
                    "<canvas id='gravityCanvas'></canvas>",
                    "<div class='charge-indicator'></div>"
                ],
                "css": [
                    "body {",
                    "  margin: 0;",
                    "  overflow: hidden;",
                    "  background: #111;",
                    "}",
                    "",
                    "canvas {",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "}",
                    "",
                    ".charge-indicator {",
                    "  position: fixed;",
                    "  border-radius: 50%;",
                    "  pointer-events: none;",
                    "  transition: transform 0.1s;",
                    "  background: radial-gradient(",
                    "    circle,",
                    "    rgba(255, 255, 255, 0.2) 0%,",
                    "    rgba(255, 255, 255, 0) 70%",
                    "  );",
                    "}"
                ],
                "particleSystem": [
                    "class Particle {",
                    "  constructor(x, y, charge) {",
                    "    this.x = x;",
                    "    this.y = y;",
                    "    this.vx = 0;",
                    "    this.vy = 0;",
                    "    this.radius = 2 + Math.random() * 4;",
                    "    this.charge = charge;",
                    "    this.color = this.getColor(charge);",
                    "    this.life = 1;",
                    "    this.decay = 0.003;",
                    "  }",
                    "",
                    "  getColor(charge) {",
                    "    const hue = charge > 0 ? ",
                    "      60 + charge * 2 : // Warm colors for positive",
                    "      240 + charge * 2; // Cool colors for negative",
                    "    return `hsla(${hue}, 100%, 60%, ${this.life})`;",
                    "  }",
                    "",
                    "  update() {",
                    "    this.x += this.vx;",
                    "    this.y += this.vy;",
                    "    ",
                    "    // Apply drag",
                    "    this.vx *= 0.99;",
                    "    this.vy *= 0.99;",
                    "    ",
                    "    // Decay life",
                    "    this.life -= this.decay;",
                    "    this.color = this.getColor(this.charge);",
                    "    ",
                    "    // Bounce off walls with energy loss",
                    "    if (this.x < 0 || this.x > canvas.width) {",
                    "      this.vx *= -0.8;",
                    "      this.x = this.x < 0 ? 0 : canvas.width;",
                    "    }",
                    "    if (this.y < 0 || this.y > canvas.height) {",
                    "      this.vy *= -0.8;",
                    "      this.y = this.y < 0 ? 0 : canvas.height;",
                    "    }",
                    "  }",
                    "",
                    "  draw(ctx) {",
                    "    ctx.beginPath();",
                    "    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);",
                    "    ctx.fillStyle = this.color;",
                    "    ctx.fill();",
                    "",
                    "    // Add glow effect",
                    "    ctx.shadowColor = this.color;",
                    "    ctx.shadowBlur = 10;",
                    "    ctx.fill();",
                    "    ctx.shadowBlur = 0;",
                    "  }",
                    "}"
                ],
                "gravityField": [
                    "class GravityField {",
                    "  constructor() {",
                    "    this.particles = [];",
                    "    this.chargeStart = 0;",
                    "    this.charging = false;",
                    "    this.position = { x: 0, y: 0 };",
                    "  }",
                    "",
                    "  startCharge(x, y) {",
                    "    this.charging = true;",
                    "    this.chargeStart = performance.now();",
                    "    this.position = { x, y };",
                    "    ",
                    "    // Show charge indicator",
                    "    const indicator = document.querySelector('.charge-indicator');",
                    "    indicator.style.left = x + 'px';",
                    "    indicator.style.top = y + 'px';",
                    "  }",
                    "",
                    "  releaseCharge(x, y) {",
                    "    if (!this.charging) return;",
                    "",
                    "    const chargeDuration = (performance.now() - this.chargeStart) / 1000;",
                    "    const chargeStrength = Math.min(chargeDuration * 2, 10);",
                    "    ",
                    "    // Create explosion of particles",
                    "    const particleCount = Math.floor(chargeStrength * 20);",
                    "    ",
                    "    for (let i = 0; i < particleCount; i++) {",
                    "      const angle = (i / particleCount) * Math.PI * 2;",
                    "      const speed = chargeStrength * (0.5 + Math.random() * 0.5);",
                    "      const charge = chargeStrength * (Math.random() * 2 - 1);",
                    "",
                    "      const particle = new Particle(x, y, charge);",
                    "      particle.vx = Math.cos(angle) * speed;",
                    "      particle.vy = Math.sin(angle) * speed;",
                    "      ",
                    "      this.particles.push(particle);",
                    "    }",
                    "",
                    "    this.charging = false;",
                    "    ",
                    "    // Hide charge indicator",
                    "    const indicator = document.querySelector('.charge-indicator');",
                    "    indicator.style.transform = 'scale(0)';",
                    "  }",
                    "",
                    "  update() {",
                    "    // Update charge indicator",
                    "    if (this.charging) {",
                    "      const chargeDuration = (performance.now() - this.chargeStart) / 1000;",
                    "      const size = Math.min(chargeDuration * 100, 300);",
                    "      ",
                    "      const indicator = document.querySelector('.charge-indicator');",
                    "      indicator.style.transform = `scale(${size / 100})`;",
                    "      indicator.style.width = size + 'px';",
                    "      indicator.style.height = size + 'px';",
                    "      indicator.style.marginLeft = -size/2 + 'px';",
                    "      indicator.style.marginTop = -size/2 + 'px';",
                    "    }",
                    "",
                    "    // Update particles",
                    "    for (let i = this.particles.length - 1; i >= 0; i--) {",
                    "      const particle = this.particles[i];",
                    "      particle.update();",
                    "",
                    "      // Remove dead particles",
                    "      if (particle.life <= 0) {",
                    "        this.particles.splice(i, 1);",
                    "      }",
                    "    }",
                    "  }",
                    "",
                    "  draw(ctx) {",
                    "    ctx.clearRect(0, 0, canvas.width, canvas.height);",
                    "    ",
                    "    // Draw particles",
                    "    this.particles.forEach(particle => particle.draw(ctx));",
                    "  }",
                    "}"
                ],
                "eventHandlers": [
                    "const gravityField = new GravityField();",
                    "",
                    "canvas.addEventListener('mousedown', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = e.clientX - rect.left;",
                    "  const y = e.clientY - rect.top;",
                    "  gravityField.startCharge(x, y);",
                    "});",
                    "",
                    "canvas.addEventListener('mouseup', e => {",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = e.clientX - rect.left;",
                    "  const y = e.clientY - rect.top;",
                    "  gravityField.releaseCharge(x, y);",
                    "});",
                    "",
                    "// Touch support",
                    "canvas.addEventListener('touchstart', e => {",
                    "  e.preventDefault();",
                    "  const touch = e.touches[0];",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = touch.clientX - rect.left;",
                    "  const y = touch.clientY - rect.top;",
                    "  gravityField.startCharge(x, y);",
                    "});",
                    "",
                    "canvas.addEventListener('touchend', e => {",
                    "  e.preventDefault();",
                    "  const touch = e.changedTouches[0];",
                    "  const rect = canvas.getBoundingClientRect();",
                    "  const x = touch.clientX - rect.left;",
                    "  const y = touch.clientY - rect.top;",
                    "  gravityField.releaseCharge(x, y);",
                    "});"
                ],
                "mainLoop": [
                    "function animate() {",
                    "  gravityField.update();",
                    "  gravityField.draw(ctx);",
                    "  requestAnimationFrame(animate);",
                    "}",
                    "",
                    "animate();"
                ]
            }
        }
    },
    {
        "id": "qr-code-generator-1",
        "pattern_name": "Mobile-First QR Generator",
        "type": "utility_app",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Practical QR code generator with mobile-optimized interface and multiple export formats",
            "metadata": {
                "app_type": "utility",
                "interaction_type": "input_generate",
                "features": [
                    "mobile_optimized",
                    "multi_format_export",
                    "responsive_preview",
                    "size_customization",
                    "instant_generation"
                ],
                "strengths": [
                    "practical business use",
                    "excellent mobile UX",
                    "versatile export options",
                    "intuitive interface",
                    "immediate feedback"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='qr-generator'>",
                    "  <div class='input-section'>",
                    "    <input type='text' id='qrInput' placeholder='Enter text or URL'>",
                    "  </div>",
                    "",
                    "  <div class='preview-section'>",
                    "    <div id='qrPreview'></div>",
                    "    <div class='size-control'>",
                    "      <label>Size</label>",
                    "      <input type='range' id='sizeSlider' min='128' max='512' value='256'>",
                    "    </div>",
                    "  </div>",
                    "",
                    "  <div class='export-section'>",
                    "    <button class='export-btn svg'>Download SVG</button>",
                    "    <button class='export-btn png'>Download PNG</button>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".qr-generator {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 20px;",
                    "  padding: 20px;",
                    "  max-width: 100%;",
                    "  margin: 0 auto;",
                    "}",
                    "",
                    ".input-section input {",
                    "  width: 100%;",
                    "  padding: 12px;",
                    "  font-size: 16px; /* Mobile-friendly font size */",
                    "  border: 2px solid #ddd;",
                    "  border-radius: 8px;",
                    "  outline: none;",
                    "}",
                    "",
                    ".preview-section {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  align-items: center;",
                    "  gap: 15px;",
                    "}",
                    "",
                    "#qrPreview {",
                    "  width: 100%;",
                    "  max-width: 300px;",
                    "  aspect-ratio: 1;",
                    "  background: #fff;",
                    "  padding: 10px;",
                    "  border-radius: 8px;",
                    "  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);",
                    "}",
                    "",
                    ".size-control {",
                    "  width: 100%;",
                    "  max-width: 300px;",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 5px;",
                    "}",
                    "",
                    ".size-control input {",
                    "  width: 100%;",
                    "}",
                    "",
                    ".export-section {",
                    "  display: flex;",
                    "  gap: 10px;",
                    "  flex-wrap: wrap;",
                    "  justify-content: center;",
                    "}",
                    "",
                    ".export-btn {",
                    "  padding: 12px 24px;",
                    "  border: none;",
                    "  border-radius: 8px;",
                    "  font-size: 16px;",
                    "  font-weight: 500;",
                    "  cursor: pointer;",
                    "  transition: all 0.2s;",
                    "  min-width: 140px;",
                    "  touch-action: manipulation; /* Better touch handling */",
                    "}",
                    "",
                    ".export-btn.svg {",
                    "  background: #4CAF50;",
                    "  color: white;",
                    "}",
                    "",
                    ".export-btn.png {",
                    "  background: #2196F3;",
                    "  color: white;",
                    "}",
                    "",
                    "/* Mobile Optimizations */",
                    "@media (max-width: 480px) {",
                    "  .qr-generator {",
                    "    padding: 15px;",
                    "  }",
                    "",
                    "  .export-btn {",
                    "    flex: 1;",
                    "    min-width: 0;",
                    "  }",
                    "}"
                ],
                "javascript": [
                    "class QRGenerator {",
                    "  constructor() {",
                    "    this.input = document.getElementById('qrInput');",
                    "    this.preview = document.getElementById('qrPreview');",
                    "    this.sizeSlider = document.getElementById('sizeSlider');",
                    "    this.setupEventListeners();",
                    "  }",
                    "",
                    "  setupEventListeners() {",
                    "    // Debounced input handler for better mobile performance",
                    "    let timeout;",
                    "    this.input.addEventListener('input', () => {",
                    "      clearTimeout(timeout);",
                    "      timeout = setTimeout(() => this.generateQR(), 300);",
                    "    });",
                    "",
                    "    this.sizeSlider.addEventListener('input', () => {",
                    "      this.generateQR();",
                    "    });",
                    "",
                    "    document.querySelector('.export-btn.svg').addEventListener('click', () => {",
                    "      this.exportQR('svg');",
                    "    });",
                    "",
                    "    document.querySelector('.export-btn.png').addEventListener('click', () => {",
                    "      this.exportQR('png');",
                    "    });",
                    "  }",
                    "",
                    "  generateQR() {",
                    "    const text = this.input.value.trim();",
                    "    const size = this.sizeSlider.value;",
                    "",
                    "    if (!text) {",
                    "      this.preview.innerHTML = '<div class=\"placeholder\">Enter text to generate QR code</div>';",
                    "      return;",
                    "    }",
                    "",
                    "    // Use qrcode-generator library",
                    "    const qr = qrcode(0, 'L');",
                    "    qr.addData(text);",
                    "    qr.make();",
                    "",
                    "    this.preview.innerHTML = qr.createImgTag(size / 25);",
                    "  }",
                    "",
                    "  exportQR(format) {",
                    "    const text = this.input.value.trim();",
                    "    if (!text) return;",
                    "",
                    "    const size = this.sizeSlider.value;",
                    "    const qr = qrcode(0, 'L');",
                    "    qr.addData(text);",
                    "    qr.make();",
                    "",
                    "    if (format === 'svg') {",
                    "      const svg = qr.createSvgTag(size / 25);",
                    "      const blob = new Blob([svg], { type: 'image/svg+xml' });",
                    "      this.downloadFile(blob, 'qrcode.svg');",
                    "    } else {",
                    "      const canvas = document.createElement('canvas');",
                    "      canvas.width = size;",
                    "      canvas.height = size;",
                    "      const ctx = canvas.getContext('2d');",
                    "      const img = this.preview.querySelector('img');",
                    "      ctx.drawImage(img, 0, 0, size, size);",
                    "      canvas.toBlob(blob => {",
                    "        this.downloadFile(blob, 'qrcode.png');",
                    "      });",
                    "    }",
                    "  }",
                    "",
                    "  downloadFile(blob, filename) {",
                    "    const url = URL.createObjectURL(blob);",
                    "    const a = document.createElement('a');",
                    "    a.href = url;",
                    "    a.download = filename;",
                    "    a.click();",
                    "    URL.revokeObjectURL(url);",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "matrix-screensaver-1",
        "pattern_name": "Customizable Matrix Rain",
        "type": "visual_effect",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Highly configurable Matrix-style digital rain animation with binary and ASCII support",
            "metadata": {
                "visual_type": "matrix_animation",
                "interaction_type": "settings_menu",
                "features": [
                    "binary_ascii_modes",
                    "speed_control",
                    "font_sizing",
                    "color_customization",
                    "hamburger_menu",
                    "defaults_reset"
                ],
                "strengths": [
                    "authentic matrix aesthetic",
                    "practical customization",
                    "user-friendly controls",
                    "multiple character modes",
                    "responsive design"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='matrix-container'>",
                    "  <canvas id='matrixCanvas'></canvas>",
                    "  ",
                    "  <div class='settings-menu'>",
                    "    <button class='hamburger'>☰</button>",
                    "    <div class='menu-content'>",
                    "      <div class='setting-group'>",
                    "        <label>Character Mode</label>",
                    "        <select id='charMode'>",
                    "          <option value='matrix'>Matrix</option>",
                    "          <option value='binary'>Binary</option>",
                    "          <option value='ascii'>ASCII</option>",
                    "        </select>",
                    "      </div>",
                    "",
                    "      <div class='setting-group'>",
                    "        <label>Font Size</label>",
                    "        <input type='range' id='fontSize' min='8' max='24' value='14'>",
                    "      </div>",
                    "",
                    "      <div class='setting-group'>",
                    "        <label>Speed</label>",
                    "        <input type='range' id='speed' min='1' max='20' value='10'>",
                    "      </div>",
                    "",
                    "      <div class='setting-group'>",
                    "        <label>Colors</label>",
                    "        <input type='color' id='textColor' value='#00ff00'>",
                    "        <input type='color' id='bgColor' value='#000000'>",
                    "      </div>",
                    "",
                    "      <button id='resetDefaults'>Restore Defaults</button>",
                    "    </div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".matrix-container {",
                    "  position: relative;",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "  overflow: hidden;",
                    "}",
                    "",
                    "canvas {",
                    "  position: absolute;",
                    "  top: 0;",
                    "  left: 0;",
                    "}",
                    "",
                    ".settings-menu {",
                    "  position: fixed;",
                    "  top: 20px;",
                    "  right: 20px;",
                    "  z-index: 1000;",
                    "}",
                    "",
                    ".hamburger {",
                    "  background: rgba(0, 0, 0, 0.7);",
                    "  color: #00ff00;",
                    "  border: 1px solid #00ff00;",
                    "  padding: 10px;",
                    "  cursor: pointer;",
                    "  font-size: 20px;",
                    "}",
                    "",
                    ".menu-content {",
                    "  position: absolute;",
                    "  right: 0;",
                    "  top: 100%;",
                    "  background: rgba(0, 0, 0, 0.9);",
                    "  padding: 20px;",
                    "  border: 1px solid #00ff00;",
                    "  display: none;",
                    "}",
                    "",
                    ".menu-content.active {",
                    "  display: block;",
                    "}",
                    "",
                    ".setting-group {",
                    "  margin-bottom: 15px;",
                    "  color: #00ff00;",
                    "}",
                    "",
                    "input, select {",
                    "  background: #000;",
                    "  color: #00ff00;",
                    "  border: 1px solid #00ff00;",
                    "  padding: 5px;",
                    "  width: 100%;",
                    "}",
                    "",
                    "#resetDefaults {",
                    "  background: #00ff00;",
                    "  color: #000;",
                    "  border: none;",
                    "  padding: 8px 16px;",
                    "  cursor: pointer;",
                    "  width: 100%;",
                    "}"
                ],
                "javascript": [
                    "class MatrixRain {",
                    "  constructor() {",
                    "    this.canvas = document.getElementById('matrixCanvas');",
                    "    this.ctx = this.canvas.getContext('2d');",
                    "    this.resizeCanvas();",
                    "    this.setupCharacters();",
                    "    this.initializeDrops();",
                    "    this.loadSettings();",
                    "  }",
                    "",
                    "  setupCharacters() {",
                    "    this.charSets = {",
                    "      matrix: '｢｣┌┐└┘├┤┬┴┼◢◣◤◥□△○',",
                    "      binary: '01',",
                    "      ascii: '!@#$%^&*()_+-=[]{}|;:,.<>?'",
                    "    };",
                    "    this.currentCharSet = this.charSets.matrix;",
                    "  }",
                    "",
                    "  initializeDrops() {",
                    "    this.drops = [];",
                    "    const columns = Math.floor(this.canvas.width / this.fontSize);",
                    "    ",
                    "    for (let i = 0; i < columns; i++) {",
                    "      this.drops[i] = {",
                    "        x: i * this.fontSize,",
                    "        y: Math.random() * -100,",
                    "        speed: Math.random() * 2 + 1,",
                    "        chars: this.generateChars(20)",
                    "      };",
                    "    }",
                    "  }",
                    "",
                    "  generateChars(length) {",
                    "    return Array.from({ length }, () =>",
                    "      this.currentCharSet[Math.floor(Math.random() * this.currentCharSet.length)]",
                    "    );",
                    "  }",
                    "",
                    "  draw() {",
                    "    // Create fade effect",
                    "    this.ctx.fillStyle = `rgba(0, 0, 0, ${this.fadeSpeed})`;",
                    "    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);",
                    "",
                    "    this.ctx.font = `${this.fontSize}px monospace`;",
                    "    ",
                    "    this.drops.forEach(drop => {",
                    "      // Draw character trail",
                    "      drop.chars.forEach((char, i) => {",
                    "        const y = drop.y - (i * this.fontSize);",
                    "        if (y < this.canvas.height && y > 0) {",
                    "          const alpha = 1 - (i / drop.chars.length);",
                    "          this.ctx.fillStyle = `rgba(0, 255, 0, ${alpha})`;",
                    "          this.ctx.fillText(char, drop.x, y);",
                    "        }",
                    "      });",
                    "",
                    "      // Update position",
                    "      drop.y += drop.speed * this.speed;",
                    "",
                    "      // Reset when off screen",
                    "      if (drop.y > this.canvas.height + drop.chars.length * this.fontSize) {",
                    "        drop.y = -this.fontSize;",
                    "        drop.chars = this.generateChars(20);",
                    "      }",
                    "    });",
                    "",
                    "    requestAnimationFrame(() => this.draw());",
                    "  }",
                    "",
                    "  updateCharMode(mode) {",
                    "    this.currentCharSet = this.charSets[mode];",
                    "    this.drops.forEach(drop => {",
                    "      drop.chars = this.generateChars(20);",
                    "    });",
                    "  }",
                    "",
                    "  resizeCanvas() {",
                    "    this.canvas.width = window.innerWidth;",
                    "    this.canvas.height = window.innerHeight;",
                    "    this.initializeDrops();",
                    "  }",
                    "",
                    "  loadSettings() {",
                    "    const defaults = {",
                    "      fontSize: 14,",
                    "      speed: 10,",
                    "      charMode: 'matrix',",
                    "      textColor: '#00ff00',",
                    "      bgColor: '#000000'",
                    "    };",
                    "",
                    "    Object.entries(defaults).forEach(([key, value]) => {",
                    "      const element = document.getElementById(key);",
                    "      if (element) {",
                    "        element.value = localStorage.getItem(key) || value;",
                    "        this.updateSetting(key, element.value);",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  updateSetting(key, value) {",
                    "    localStorage.setItem(key, value);",
                    "    ",
                    "    switch(key) {",
                    "      case 'fontSize':",
                    "        this.fontSize = parseInt(value);",
                    "        this.initializeDrops();",
                    "        break;",
                    "      case 'speed':",
                    "        this.speed = parseFloat(value) / 5;",
                    "        break;",
                    "      case 'charMode':",
                    "        this.updateCharMode(value);",
                    "        break;",
                    "      case 'textColor':",
                    "        document.documentElement.style.setProperty('--text-color', value);",
                    "        break;",
                    "      case 'bgColor':",
                    "        document.body.style.backgroundColor = value;",
                    "        break;",
                    "    }",
                    "  }",
                    "}"
                ],
                "eventHandlers": [
                    "const matrix = new MatrixRain();",
                    "",
                    "// Menu toggle",
                    "document.querySelector('.hamburger').addEventListener('click', () => {",
                    "  document.querySelector('.menu-content').classList.toggle('active');",
                    "});",
                    "",
                    "// Settings handlers",
                    "document.querySelectorAll('input, select').forEach(element => {",
                    "  element.addEventListener('change', e => {",
                    "    matrix.updateSetting(e.target.id, e.target.value);",
                    "  });",
                    "});",
                    "",
                    "// Reset defaults",
                    "document.getElementById('resetDefaults').addEventListener('click', () => {",
                    "  localStorage.clear();",
                    "  matrix.loadSettings();",
                    "});",
                    "",
                    "// Responsive resize",
                    "window.addEventListener('resize', () => matrix.resizeCanvas());"
                ]
            }
        }
    },
    {
        "id": "quantum-candlesticks-1",
        "pattern_name": "Multi-Library Chart Memes",
        "type": "data_visualization",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Creative integration of multiple charting libraries for meme-worthy crypto visualizations",
            "metadata": {
                "visual_type": "financial_charts",
                "libraries": ["tradingview", "chartjs", "d3", "jquery", "jsap"],
                "features": [
                    "candlestick_charts",
                    "real_time_updates",
                    "multiple_visualizations",
                    "library_integration",
                    "meme_aesthetics"
                ],
                "strengths": [
                    "creative library usage",
                    "seamless integration",
                    "performance optimization",
                    "modular design",
                    "humorous presentation"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='chart-container'>",
                    "  <div class='chart-grid'>",
                    "    <!-- TradingView Chart -->",
                    "    <div class='chart-cell'>",
                    "      <div class='tv-chart-container'></div>",
                    "    </div>",
                    "",
                    "    <!-- Chart.js Implementation -->",
                    "    <div class='chart-cell'>",
                    "      <canvas id='chartjs-canvas'></canvas>",
                    "    </div>",
                    "",
                    "    <!-- D3 Visualization -->",
                    "    <div class='chart-cell'>",
                    "      <div id='d3-container'></div>",
                    "    </div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".chart-container {",
                    "  padding: 20px;",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "}",
                    "",
                    ".chart-grid {",
                    "  display: grid;",
                    "  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));",
                    "  gap: 20px;",
                    "}",
                    "",
                    ".chart-cell {",
                    "  background: #2a2a2a;",
                    "  border-radius: 8px;",
                    "  padding: 15px;",
                    "  min-height: 300px;",
                    "  position: relative;",
                    "  overflow: hidden;",
                    "}",
                    "",
                    ".chart-cell::before {",
                    "  content: '🚀';",
                    "  position: absolute;",
                    "  top: 10px;",
                    "  right: 10px;",
                    "  font-size: 24px;",
                    "  opacity: 0.5;",
                    "}"
                ],
                "tradingview": [
                    "// TradingView Widget Integration",
                    "new TradingView.widget({",
                    "  container_id: 'tv-chart',",
                    "  width: '100%',",
                    "  height: '100%',",
                    "  symbol: 'BINANCE:BTCUSDT',",
                    "  interval: '1',",
                    "  theme: 'dark',",
                    "  style: '1',",
                    "  locale: 'en',",
                    "  toolbar_bg: '#2a2a2a',",
                    "  enable_publishing: false,",
                    "  hide_side_toolbar: false,",
                    "  allow_symbol_change: true,",
                    "  studies: [",
                    "    'MASimple@tv-basicstudies',",
                    "    'RSI@tv-basicstudies'",
                    "  ]",
                    "});"
                ],
                "chartjs": [
                    "// Chart.js Meme Implementation",
                    "const ctx = document.getElementById('chartjs-canvas').getContext('2d');",
                    "new Chart(ctx, {",
                    "  type: 'candlestick',",
                    "  data: {",
                    "    datasets: [{",
                    "      label: 'HODL Index',",
                    "      data: generateMemeData(),",
                    "      color: {",
                    "        up: '#00ff00',",
                    "        down: '#ff0000',",
                    "        unchanged: '#999'",
                    "      }",
                    "    }]",
                    "  },",
                    "  options: {",
                    "    animation: {",
                    "      duration: 2000,",
                    "      easing: 'easeInOutQuart'",
                    "    },",
                    "    scales: {",
                    "      y: {",
                    "        ticks: {",
                    "          callback: value => `${value} 🌕`",
                    "        }",
                    "      }",
                    "    },",
                    "    plugins: {",
                    "      tooltip: {",
                    "        callbacks: {",
                    "          label: ctx => `Much ${ctx.raw.c} 🐕`",
                    "        }",
                    "      }",
                    "    }",
                    "  }",
                    "});"
                ],
                "d3": [
                    "// D3 Quantum Visualization",
                    "const svg = d3.select('#d3-container')",
                    "  .append('svg')",
                    "  .attr('width', width)",
                    "  .attr('height', height);",
                    "",
                    "// Create quantum effect",
                    "const quantumEffect = svg.append('g')",
                    "  .selectAll('circle')",
                    "  .data(generateQuantumData())",
                    "  .enter()",
                    "  .append('circle')",
                    "  .attr('cx', d => xScale(d.time))",
                    "  .attr('cy', d => yScale(d.price))",
                    "  .attr('r', d => d.volume / 1000)",
                    "  .style('fill', d => d3.interpolateRainbow(d.sentiment))",
                    "  .style('opacity', 0.6)",
                    "  .style('mix-blend-mode', 'screen');",
                    "",
                    "// Add particle effects",
                    "function animateParticles() {",
                    "  quantumEffect",
                    "    .transition()",
                    "    .duration(1000)",
                    "    .attr('r', d => (Math.random() * d.volume) / 500)",
                    "    .style('opacity', d => Math.random())",
                    "    .on('end', animateParticles);",
                    "}"
                ],
                "dataGeneration": [
                    "function generateMemeData() {",
                    "  const memeEvents = [",
                    "    'DOGE Day',",
                    "    'Diamond Hands',",
                    "    'To The Moon',",
                    "    'Buy The Dip',",
                    "    'WAGMI'",
                    "  ];",
                    "",
                    "  return Array.from({ length: 100 }, (_, i) => ({",
                    "    t: new Date(Date.now() - (100 - i) * 86400000),",
                    "    o: Math.random() * 100,",
                    "    h: Math.random() * 120,",
                    "    l: Math.random() * 80,",
                    "    c: Math.random() * 100,",
                    "    event: Math.random() > 0.9 ? ",
                    "      memeEvents[Math.floor(Math.random() * memeEvents.length)] :",
                    "      null",
                    "  }));",
                    "}"
                ],
                "integration": [
                    "// JSAP Integration for Real-time Updates",
                    "$.jsap.subscribe('crypto.prices', data => {",
                    "  updateCharts(data);",
                    "  updateMemeOverlays(data);",
                    "  triggerQuantumEffects(data);",
                    "});",
                    "",
                    "// jQuery Event Handlers",
                    "$('.chart-cell').on('click', function() {",
                    "  $(this).addClass('quantum-zoom');",
                    "  setTimeout(() => {",
                    "    $(this).removeClass('quantum-zoom');",
                    "  }, 1000);",
                    "});"
                ]
            }
        }
    },
    {
        "id": "pirate-game-1",
        "pattern_name": "Top-Down Ship Combat",
        "type": "game_mechanics",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Polished top-down naval combat game with progression and power-ups",
            "metadata": {
                "game_type": "arcade_combat",
                "view_type": "top_down",
                "features": [
                    "hp_system",
                    "keyboard_controls",
                    "checkpoints",
                    "power_ups",
                    "level_progression",
                    "scoring_system"
                ],
                "strengths": [
                    "excellent progression system",
                    "balanced power-ups",
                    "responsive controls",
                    "clear feedback",
                    "engaging gameplay loop"
                ]
            },
            "implementation": {
                "gameState": [
                    "const gameState = {",
                    "  player: {",
                    "    x: 0,",
                    "    y: 0,",
                    "    hp: 100,",
                    "    maxHp: 100,",
                    "    speed: 5,",
                    "    attackRange: 200,",
                    "    attackSpeed: 1,",
                    "    level: 1,",
                    "    score: 0,",
                    "    powerUps: []",
                    "  },",
                    "  enemies: [],",
                    "  projectiles: [],",
                    "  checkpoints: [],",
                    "  gameTime: 0,",
                    "  nextCheckpoint: 30 // seconds",
                    "};"
                ],
                "playerControls": [
                    "function handleInput() {",
                    "  const player = gameState.player;",
                    "  ",
                    "  // Smooth movement with acceleration",
                    "  if (keys.ArrowLeft) player.vx = Math.max(-player.speed, player.vx - 0.5);",
                    "  if (keys.ArrowRight) player.vx = Math.min(player.speed, player.vx + 0.5);",
                    "  if (keys.ArrowUp) player.vy = Math.max(-player.speed, player.vy - 0.5);",
                    "  if (keys.ArrowDown) player.vy = Math.min(player.speed, player.vy + 0.5);",
                    "",
                    "  // Apply water resistance/friction",
                    "  player.vx *= 0.98;",
                    "  player.vy *= 0.98;",
                    "",
                    "  // Update position",
                    "  player.x += player.vx;",
                    "  player.y += player.vy;",
                    "",
                    "  // Keep player in bounds",
                    "  player.x = Math.max(0, Math.min(canvas.width, player.x));",
                    "  player.y = Math.max(0, Math.min(canvas.height, player.y));",
                    "}"
                ],
                "combatSystem": [
                    "function handleCombat() {",
                    "  // Auto-fire at nearest enemy within range",
                    "  const player = gameState.player;",
                    "  const now = performance.now();",
                    "",
                    "  if (now - player.lastShot > 1000 / player.attackSpeed) {",
                    "    const nearestEnemy = findNearestEnemy();",
                    "    if (nearestEnemy && getDistance(player, nearestEnemy) <= player.attackRange) {",
                    "      fireProjectile(player, nearestEnemy);",
                    "      player.lastShot = now;",
                    "    }",
                    "  }",
                    "",
                    "  // Update projectiles",
                    "  gameState.projectiles.forEach((proj, i) => {",
                    "    proj.x += proj.vx;",
                    "    proj.y += proj.vy;",
                    "",
                    "    // Check collisions",
                    "    if (proj.fromPlayer) {",
                    "      gameState.enemies.forEach(enemy => {",
                    "        if (checkCollision(proj, enemy)) {",
                    "          enemy.hp -= proj.damage;",
                    "          if (enemy.hp <= 0) {",
                    "            gameState.score += enemy.points;",
                    "            spawnPowerUp(enemy.x, enemy.y);",
                    "          }",
                    "          gameState.projectiles.splice(i, 1);",
                    "        }",
                    "      });",
                    "    } else if (checkCollision(proj, player)) {",
                    "      player.hp -= proj.damage;",
                    "      gameState.projectiles.splice(i, 1);",
                    "      showDamageIndicator();",
                    "    }",
                    "  });"
                ],
                "progressionSystem": [
                    "function handleCheckpoint() {",
                    "  const timeElapsed = Math.floor(gameState.gameTime / 1000);",
                    "  ",
                    "  if (timeElapsed >= gameState.nextCheckpoint) {",
                    "    pauseGame();",
                    "    showPowerUpChoices([",
                    "      {",
                    "        name: 'Speed Boost',",
                    "        effect: () => {",
                    "          gameState.player.speed *= 1.2;",
                    "        }",
                    "      },",
                    "      {",
                    "        name: 'Attack Range',",
                    "        effect: () => {",
                    "          gameState.player.attackRange *= 1.3;",
                    "        }",
                    "      },",
                    "      {",
                    "        name: 'Attack Speed',",
                    "        effect: () => {",
                    "          gameState.player.attackSpeed *= 1.25;",
                    "        }",
                    "      },",
                    "      {",
                    "        name: 'Max HP',",
                    "        effect: () => {",
                    "          gameState.player.maxHp *= 1.3;",
                    "          gameState.player.hp = gameState.player.maxHp;",
                    "        }",
                    "      }",
                    "    ]);",
                    "",
                    "    gameState.nextCheckpoint += 30;",
                    "    gameState.player.level++;",
                    "    increaseEnemyDifficulty();",
                    "  }",
                    "}"
                ],
                "visualFeedback": [
                    "function render() {",
                    "  // Clear canvas",
                    "  ctx.clearRect(0, 0, canvas.width, canvas.height);",
                    "",
                    "  // Draw water background with parallax",
                    "  drawWaterBackground();",
                    "",
                    "  // Draw player ship",
                    "  ctx.save();",
                    "  ctx.translate(gameState.player.x, gameState.player.y);",
                    "  ctx.rotate(Math.atan2(gameState.player.vy, gameState.player.vx));",
                    "  drawShip(ctx);",
                    "  ctx.restore();",
                    "",
                    "  // Draw HP bar",
                    "  const hp = gameState.player.hp;",
                    "  const maxHp = gameState.player.maxHp;",
                    "  ctx.fillStyle = '#333';",
                    "  ctx.fillRect(10, 10, 200, 20);",
                    "  ctx.fillStyle = hp > maxHp * 0.3 ? '#2ecc71' : '#e74c3c';",
                    "  ctx.fillRect(10, 10, (hp / maxHp) * 200, 20);",
                    "",
                    "  // Draw score and level",
                    "  ctx.font = '24px Arial';",
                    "  ctx.fillStyle = '#fff';",
                    "  ctx.fillText(`Score: ${gameState.score}`, 10, 50);",
                    "  ctx.fillText(`Level: ${gameState.player.level}`, 10, 80);",
                    "",
                    "  // Draw checkpoint timer",
                    "  const timeToNext = Math.ceil(gameState.nextCheckpoint - gameState.gameTime / 1000);",
                    "  ctx.fillText(`Next Power-up: ${timeToNext}s`, 10, 110);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "responsive-video-player-1",
        "pattern_name": "Responsive Video Playlist Player",
        "type": "media_player",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Full-screen responsive video player with episode playlist support",
            "metadata": {
                "player_type": "video_playlist",
                "layout_type": "responsive",
                "features": [
                    "mobile_responsive",
                    "episode_navigation",
                    "playlist_management",
                    "fullscreen_support",
                    "progress_tracking"
                ],
                "strengths": [
                    "excellent mobile adaptation",
                    "intuitive playlist UI",
                    "seamless episode switching",
                    "responsive controls",
                    "clean layout"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='video-player-container'>",
                    "  <div class='video-wrapper'>",
                    "    <video id='mainPlayer'>",
                    "      <source src='' type='video/mp4'>",
                    "    </video>",
                    "    <div class='video-controls'>",
                    "      <div class='progress-bar'>",
                    "        <div class='progress'></div>",
                    "      </div>",
                    "      <div class='control-buttons'>",
                    "        <button class='play-pause'>▶️</button>",
                    "        <button class='prev-episode'>⏮️</button>",
                    "        <button class='next-episode'>⏭️</button>",
                    "        <div class='volume-control'>",
                    "          <button class='mute'>🔊</button>",
                    "          <input type='range' class='volume' min='0' max='1' step='0.1' value='1'>",
                    "        </div>",
                    "        <button class='fullscreen'>⛶</button>",
                    "      </div>",
                    "    </div>",
                    "  </div>",
                    "",
                    "  <div class='playlist-container'>",
                    "    <h2>Episodes</h2>",
                    "    <div class='episode-list'></div>",
                    "  </div>",
                    "</div>"
                ],
                "css": [
                    ".video-player-container {",
                    "  display: grid;",
                    "  grid-template-columns: 1fr 300px;",
                    "  height: 100vh;",
                    "  background: #000;",
                    "}",
                    "",
                    "@media (max-width: 768px) {",
                    "  .video-player-container {",
                    "    grid-template-columns: 1fr;",
                    "    grid-template-rows: 1fr auto;",
                    "  }",
                    "",
                    "  .playlist-container {",
                    "    max-height: 30vh;",
                    "    overflow-y: auto;",
                    "  }",
                    "}",
                    "",
                    ".video-wrapper {",
                    "  position: relative;",
                    "  width: 100%;",
                    "  height: 100%;",
                    "  background: #000;",
                    "}",
                    "",
                    "video {",
                    "  width: 100%;",
                    "  height: 100%;",
                    "  object-fit: contain;",
                    "}",
                    "",
                    ".video-controls {",
                    "  position: absolute;",
                    "  bottom: 0;",
                    "  left: 0;",
                    "  right: 0;",
                    "  background: rgba(0, 0, 0, 0.7);",
                    "  padding: 10px;",
                    "  opacity: 0;",
                    "  transition: opacity 0.3s;",
                    "}",
                    "",
                    ".video-wrapper:hover .video-controls {",
                    "  opacity: 1;",
                    "}",
                    "",
                    ".progress-bar {",
                    "  width: 100%;",
                    "  height: 5px;",
                    "  background: rgba(255, 255, 255, 0.3);",
                    "  cursor: pointer;",
                    "  margin-bottom: 10px;",
                    "}",
                    "",
                    ".progress {",
                    "  height: 100%;",
                    "  background: #ff0000;",
                    "  width: 0;",
                    "}",
                    "",
                    ".control-buttons {",
                    "  display: flex;",
                    "  align-items: center;",
                    "  gap: 10px;",
                    "}",
                    "",
                    ".playlist-container {",
                    "  background: #1a1a1a;",
                    "  color: #fff;",
                    "  padding: 20px;",
                    "  overflow-y: auto;",
                    "}",
                    "",
                    ".episode-list {",
                    "  display: flex;",
                    "  flex-direction: column;",
                    "  gap: 10px;",
                    "}",
                    "",
                    ".episode-item {",
                    "  padding: 10px;",
                    "  background: #333;",
                    "  border-radius: 5px;",
                    "  cursor: pointer;",
                    "  transition: background 0.2s;",
                    "}",
                    "",
                    ".episode-item:hover {",
                    "  background: #444;",
                    "}",
                    "",
                    ".episode-item.active {",
                    "  background: #ff0000;",
                    "}"
                ],
                "javascript": [
                    "class VideoPlayer {",
                    "  constructor() {",
                    "    this.video = document.getElementById('mainPlayer');",
                    "    this.playlist = [];",
                    "    this.currentEpisode = 0;",
                    "    this.setupEventListeners();",
                    "  }",
                    "",
                    "  setupEventListeners() {",
                    "    // Progress tracking",
                    "    this.video.addEventListener('timeupdate', () => {",
                    "      const progress = (this.video.currentTime / this.video.duration) * 100;",
                    "      document.querySelector('.progress').style.width = `${progress}%`;",
                    "    });",
                    "",
                    "    // Progress bar seeking",
                    "    document.querySelector('.progress-bar').addEventListener('click', e => {",
                    "      const rect = e.target.getBoundingClientRect();",
                    "      const pos = (e.clientX - rect.left) / rect.width;",
                    "      this.video.currentTime = pos * this.video.duration;",
                    "    });",
                    "",
                    "    // Play/Pause",
                    "    document.querySelector('.play-pause').addEventListener('click', () => {",
                    "      if (this.video.paused) {",
                    "        this.video.play();",
                    "        this.updatePlayButton('⏸️');",
                    "      } else {",
                    "        this.video.pause();",
                    "        this.updatePlayButton('▶️');",
                    "      }",
                    "    });",
                    "",
                    "    // Episode navigation",
                    "    document.querySelector('.prev-episode').addEventListener('click', () => {",
                    "      this.playEpisode(this.currentEpisode - 1);",
                    "    });",
                    "",
                    "    document.querySelector('.next-episode').addEventListener('click', () => {",
                    "      this.playEpisode(this.currentEpisode + 1);",
                    "    });",
                    "",
                    "    // Auto-play next episode",
                    "    this.video.addEventListener('ended', () => {",
                    "      this.playEpisode(this.currentEpisode + 1);",
                    "    });",
                    "",
                    "    // Fullscreen handling",
                    "    document.querySelector('.fullscreen').addEventListener('click', () => {",
                    "      if (document.fullscreenElement) {",
                    "        document.exitFullscreen();",
                    "      } else {",
                    "        this.video.requestFullscreen();",
                    "      }",
                    "    });",
                    "",
                    "    // Mobile touch events",
                    "    let touchStartX = 0;",
                    "    let touchStartY = 0;",
                    "",
                    "    this.video.addEventListener('touchstart', e => {",
                    "      touchStartX = e.touches[0].clientX;",
                    "      touchStartY = e.touches[0].clientY;",
                    "    });",
                    "",
                    "    this.video.addEventListener('touchend', e => {",
                    "      const touchEndX = e.changedTouches[0].clientX;",
                    "      const touchEndY = e.changedTouches[0].clientY;",
                    "      const deltaX = touchEndX - touchStartX;",
                    "      const deltaY = touchEndY - touchStartY;",
                    "",
                    "      // Horizontal swipe for seeking",
                    "      if (Math.abs(deltaX) > Math.abs(deltaY)) {",
                    "        if (Math.abs(deltaX) > 50) {",
                    "          this.video.currentTime += (deltaX > 0 ? 10 : -10);",
                    "        }",
                    "      }",
                    "      // Vertical swipe for volume",
                    "      else if (Math.abs(deltaY) > 50) {",
                    "        this.video.volume = Math.max(0, Math.min(1, ",
                    "          this.video.volume + (deltaY > 0 ? -0.1 : 0.1)",
                    "        ));",
                    "      }",
                    "    });",
                    "  }",
                    "",
                    "  playEpisode(index) {",
                    "    if (index >= 0 && index < this.playlist.length) {",
                    "      this.currentEpisode = index;",
                    "      this.video.src = this.playlist[index].url;",
                    "      this.video.play();",
                    "      this.updatePlaylistUI();",
                    "    }",
                    "  }",
                    "",
                    "  updatePlaylistUI() {",
                    "    const list = document.querySelector('.episode-list');",
                    "    list.innerHTML = '';",
                    "",
                    "    this.playlist.forEach((episode, i) => {",
                    "      const item = document.createElement('div');",
                    "      item.className = `episode-item ${i === this.currentEpisode ? 'active' : ''}`;",
                    "      item.textContent = episode.title;",
                    "      item.addEventListener('click', () => this.playEpisode(i));",
                    "      list.appendChild(item);",
                    "    });",
                    "  }",
                    "}"
                ]
            }
        }
    },
    {
        "id": "zombies-fps-1",
        "pattern_name": "Three.js FPS Game",
        "type": "game_mechanics",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Complete Three.js-based first-person shooter with comprehensive game mechanics",
            "metadata": {
                "game_type": "fps",
                "engine": "three.js",
                "features": [
                    "health_system",
                    "scoring",
                    "weapon_mechanics",
                    "enemy_ai",
                    "minimap",
                    "menu_system",
                    "ammo_system",
                    "sound_effects",
                    "keyboard_mouse_controls"
                ],
                "strengths": [
                    "complete game loop",
                    "polished mechanics",
                    "professional UI",
                    "performance optimized",
                    "modular design"
                ]
            },
            "implementation": {
                "setup": [
                    "const scene = new THREE.Scene();",
                    "const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);",
                    "const renderer = new THREE.WebGLRenderer({ antialias: true });",
                    "",
                    "const gameState = {",
                    "  player: {",
                    "    hp: 100,",
                    "    maxHp: 100,",
                    "    speed: 5,",
                    "    score: 0,",
                    "    level: 1,",
                    "    weapons: {",
                    "      pistol: { ammo: Infinity, damage: 25, fireRate: 300 },",
                    "      assaultRifle: { ammo: 30, maxAmmo: 30, damage: 20, fireRate: 100 }",
                    "    }",
                    "  },",
                    "  zombies: [],",
                    "  isPlaying: false",
                    "};"
                ],
                "controls": [
                    "// Pointer lock controls for FPS camera",
                    "const controls = new THREE.PointerLockControls(camera, renderer.domElement);",
                    "",
                    "document.addEventListener('click', () => {",
                    "  if (!controls.isLocked) {",
                    "    controls.lock();",
                    "  }",
                    "});",
                    "",
                    "// Movement controls",
                    "const moveForward = moveBackward = moveLeft = moveRight = false;",
                    "const velocity = new THREE.Vector3();",
                    "const direction = new THREE.Vector3();",
                    "",
                    "document.addEventListener('keydown', e => {",
                    "  switch(e.code) {",
                    "    case 'KeyW': moveForward = true; break;",
                    "    case 'KeyS': moveBackward = true; break;",
                    "    case 'KeyA': moveLeft = true; break;",
                    "    case 'KeyD': moveRight = true; break;",
                    "    case 'Space': if (canJump) jump(); break;",
                    "    case 'KeyR': reload(); break;",
                    "  }",
                    "});"
                ],
                "weaponSystem": [
                    "function shoot() {",
                    "  const currentWeapon = weapons[currentWeaponIndex];",
                    "  ",
                    "  if (currentWeapon.ammo > 0 || currentWeapon.ammo === Infinity) {",
                    "    if (currentWeapon.ammo !== Infinity) currentWeapon.ammo--;",
                    "    ",
                    "    const raycaster = new THREE.Raycaster();",
                    "    raycaster.setFromCamera(new THREE.Vector2(), camera);",
                    "    ",
                    "    const intersects = raycaster.intersectObjects(zombies);",
                    "    if (intersects.length > 0) {",
                    "      const hitZombie = intersects[0].object.parent;",
                    "      scene.remove(hitZombie);",
                    "      zombies = zombies.filter(z => z !== hitZombie);",
                    "      score += 10;",
                    "      playSound(sounds.zombieDeath);",
                    "    }",
                    "    ",
                    "    // Weapon recoil animation",
                    "    currentWeapon.model.position.z += 0.1;",
                    "    setTimeout(() => {",
                    "      currentWeapon.model.position.z -= 0.1;",
                    "    }, 50);",
                    "  } else {",
                    "    playSound(sounds.emptyClip);",
                    "  }",
                    "}"
                ],
                "zombieAI": [
                    "function updateZombies() {",
                    "  zombies.forEach(zombie => {",
                    "    const direction = new THREE.Vector3();",
                    "    direction.subVectors(camera.position, zombie.position);",
                    "    direction.normalize();",
                    "    ",
                    "    // Keep zombies on ground",
                    "    direction.y = 0;",
                    "    ",
                    "    // Move towards player",
                    "    zombie.position.add(direction.multiplyScalar(0.03 + level * 0.005));",
                    "    ",
                    "    // Face player",
                    "    zombie.lookAt(new THREE.Vector3(camera.position.x, 0, camera.position.z));",
                    "    ",
                    "    // Attack if close enough",
                    "    if (zombie.position.distanceTo(camera.position) < ATTACK_RANGE) {",
                    "      zombieAttack(zombie);",
                    "    }",
                    "  });",
                    "}"
                ],
                "ui": [
                    "// HUD elements",
                    "const hud = document.getElementById('hud');",
                    "const healthDisplay = document.getElementById('health');",
                    "const scoreDisplay = document.getElementById('score');",
                    "const ammoDisplay = document.getElementById('ammo');",
                    "",
                    "function updateHUD() {",
                    "  healthDisplay.textContent = gameState.player.hp;",
                    "  scoreDisplay.textContent = gameState.player.score;",
                    "  ",
                    "  const currentWeapon = weapons[currentWeaponIndex];",
                    "  ammoDisplay.textContent = currentWeapon.ammo === Infinity ? '∞' : currentWeapon.ammo;",
                    "}",
                    "",
                    "// Minimap",
                    "function updateMinimap() {",
                    "  const ctx = minimapContext;",
                    "  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';",
                    "  ctx.fillRect(0, 0, 200, 200);",
                    "",
                    "  // Draw player",
                    "  ctx.fillStyle = '#00ffff';",
                    "  ctx.beginPath();",
                    "  ctx.arc(100, 100, 5, 0, Math.PI * 2);",
                    "  ctx.fill();",
                    "",
                    "  // Draw zombies",
                    "  ctx.fillStyle = '#00ff00';",
                    "  zombies.forEach(zombie => {",
                    "    const x = 100 + (zombie.position.x - camera.position.x) / 2;",
                    "    const y = 100 + (zombie.position.z - camera.position.z) / 2;",
                    "    ctx.beginPath();",
                    "    ctx.arc(x, y, 3, 0, Math.PI * 2);",
                    "    ctx.fill();",
                    "  });",
                    "}"
                ],
                "gameLoop": [
                    "function animate() {",
                    "  requestAnimationFrame(animate);",
                    "",
                    "  if (controls.isLocked) {",
                    "    // Update physics",
                    "    const delta = clock.getDelta();",
                    "    velocity.x -= velocity.x * 10.0 * delta;",
                    "    velocity.z -= velocity.z * 10.0 * delta;",
                    "    velocity.y += GRAVITY * delta;",
                    "",
                    "    // Update movement",
                    "    direction.z = Number(moveForward) - Number(moveBackward);",
                    "    direction.x = Number(moveRight) - Number(moveLeft);",
                    "    direction.normalize();",
                    "",
                    "    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;",
                    "    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;",
                    "",
                    "    controls.moveRight(-velocity.x * delta);",
                    "    controls.moveForward(-velocity.z * delta);",
                    "",
                    "    // Update game elements",
                    "    updateZombies();",
                    "    updateHUD();",
                    "    updateMinimap();",
                    "  }",
                    "",
                    "  renderer.render(scene, camera);",
                    "}"
                ]
            }
        }
    },
    {
        "id": "iframe-embed-1",
        "pattern_name": "Responsive Game Embed",
        "type": "embedding",
        "effectiveness_score": 1.0,
        "usage_count": 1,
        "content": {
            "context": "Clean and responsive iframe implementation for embedding external game content",
            "metadata": {
                "embed_type": "iframe",
                "interaction_type": "fullscreen_capable",
                "features": [
                    "responsive_layout",
                    "fullscreen_support",
                    "gamepad_support",
                    "clean_styling",
                    "message_handling"
                ],
                "strengths": [
                    "minimal implementation",
                    "proper fullscreen handling",
                    "responsive design",
                    "cross-browser support",
                    "secure embedding"
                ]
            },
            "implementation": {
                "html": [
                    "<div class='frame-wrapper'>",
                    "  <iframe src='GAME_URL'",
                    "          allow='fullscreen; gamepad'></iframe>",
                    "</div>"
                ],
                "css": [
                    "body {",
                    "  margin: 0;",
                    "  padding: 0;",
                    "}",
                    "",
                    ".frame-wrapper {",
                    "  position: relative;",
                    "  width: 100vw;",
                    "  height: 100vh;",
                    "}",
                    "",
                    ".frame-wrapper iframe {",
                    "  position: absolute;",
                    "  top: 0;",
                    "  left: 0;",
                    "  width: 100%;",
                    "  height: 100%;",
                    "  border: none;",
                    "}"
                ],
                "javascript": [
                    "window.addEventListener('message', function(event) {",
                    "  if (event.data === 'requestFullscreen') {",
                    "    const iframe = document.querySelector('iframe');",
                    "    if (iframe.requestFullscreen) {",
                    "      iframe.requestFullscreen();",
                    "    } else if (iframe.webkitRequestFullscreen) {",
                    "      iframe.webkitRequestFullscreen();",
                    "    } else if (iframe.mozRequestFullScreen) {",
                    "      iframe.mozRequestFullScreen();",
                    "    }",
                    "  }",
                    "});"
                ]
            }
        }
    },
    {
        "id": "first-person-walk-1",
        "pattern_name": "First-Person Walking",
        "type": "movement_mechanics",
        "effectiveness_score": 0.9,
        "usage_count": 1,
        "content": {
            "context": "Clean first-person walking mechanics using Three.js PointerLockControls",
            "metadata": {
                "movement_type": "first_person",
                "engine": "three.js",
                "features": [
                    "pointer_lock",
                    "wasd_controls",
                    "mobile_support",
                    "smooth_movement",
                    "touch_controls"
                ],
                "strengths": [
                    "clean implementation",
                    "responsive controls",
                    "cross-platform support",
                    "easy to extend",
                    "performance optimized"
                ]
            },
            "implementation": {
                "setup": [
                    "import * as THREE from 'three';",
                    "import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';",
                    "",
                    "const scene = new THREE.Scene();",
                    "const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);",
                    "const controls = new PointerLockControls(camera, document.body);",
                    "",
                    "// Movement state",
                    "const moveState = {",
                    "  forward: false,",
                    "  backward: false,",
                    "  left: false,",
                    "  right: false,",
                    "  speed: 5.0",
                    "};"
                ],
                "controls": [
                    "// Keyboard controls",
                    "document.addEventListener('keydown', (event) => {",
                    "  switch (event.code) {",
                    "    case 'KeyW': moveState.forward = true; break;",
                    "    case 'KeyS': moveState.backward = true; break;",
                    "    case 'KeyA': moveState.left = true; break;",
                    "    case 'KeyD': moveState.right = true; break;",
                    "  }",
                    "});",
                    "",
                    "document.addEventListener('keyup', (event) => {",
                    "  switch (event.code) {",
                    "    case 'KeyW': moveState.forward = false; break;",
                    "    case 'KeyS': moveState.backward = false; break;",
                    "    case 'KeyA': moveState.left = false; break;",
                    "    case 'KeyD': moveState.right = false; break;",
                    "  }",
                    "});"
                ],
                "mobileSupport": [
                    "// Mobile joystick setup",
                    "const joystick = nipplejs.create({",
                    "  zone: document.getElementById('joystickContainer'),",
                    "  mode: 'static',",
                    "  position: { left: '100px', bottom: '100px' }",
                    "});",
                    "",
                    "joystick.on('move', (evt, data) => {",
                    "  const angle = data.angle.radian;",
                    "  const force = Math.min(data.force, 1);",
                    "",
                    "  moveState.forward = Math.abs(Math.cos(angle)) > 0.5;",
                    "  moveState.backward = Math.abs(Math.cos(angle + Math.PI)) > 0.5;",
                    "  moveState.left = Math.abs(Math.sin(angle + Math.PI/2)) > 0.5;",
                    "  moveState.right = Math.abs(Math.sin(angle - Math.PI/2)) > 0.5;",
                    "});"
                ],
                "movement": [
                    "function updateMovement(delta) {",
                    "  const velocity = new THREE.Vector3();",
                    "  const direction = new THREE.Vector3();",
                    "",
                    "  // Calculate movement direction",
                    "  direction.z = Number(moveState.forward) - Number(moveState.backward);",
                    "  direction.x = Number(moveState.right) - Number(moveState.left);",
                    "  direction.normalize();",
                    "",
                    "  // Apply movement",
                    "  if (moveState.forward || moveState.backward) {",
                    "    velocity.z -= direction.z * moveState.speed * delta;",
                    "  }",
                    "  if (moveState.left || moveState.right) {",
                    "    velocity.x -= direction.x * moveState.speed * delta;",
                    "  }",
                    "",
                    "  // Update controls",
                    "  controls.moveRight(-velocity.x);",
                    "  controls.moveForward(-velocity.z);",
                    "}"
                ],
                "touchLook": [
                    "// Touch look controls for mobile",
                    "const touchArea = document.getElementById('touchArea');",
                    "let touchStartX = 0;",
                    "let touchStartY = 0;",
                    "",
                    "touchArea.addEventListener('touchstart', e => {",
                    "  touchStartX = e.touches[0].clientX;",
                    "  touchStartY = e.touches[0].clientY;",
                    "});",
                    "",
                    "touchArea.addEventListener('touchmove', e => {",
                    "  const touchX = e.touches[0].clientX;",
                    "  const touchY = e.touches[0].clientY;",
                    "",
                    "  const deltaX = (touchX - touchStartX) * 0.002;",
                    "  const deltaY = (touchY - touchStartY) * 0.002;",
                    "",
                    "  camera.rotation.y -= deltaX;",
                    "  camera.rotation.x = Math.max(-Math.PI/2,",
                    "    Math.min(Math.PI/2, camera.rotation.x - deltaY));",
                    "",
                    "  touchStartX = touchX;",
                    "  touchStartY = touchY;",
                    "});"
                ]
            }
        }
    }
]
