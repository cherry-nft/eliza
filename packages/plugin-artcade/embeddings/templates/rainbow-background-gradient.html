<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>ðŸŒ€ Focus Shift</title>
        <style>
            /* Basic page reset */
            html,
            body {
                margin: 0;
                padding: 0;
                width: 100%;
                height: 100%;
                background: #000;
                overflow: hidden;
            }
            canvas {
                width: 100%;
                height: auto;
                display: block;
            }
        </style>
    </head>
    <body>
        <!-- Fragment Shader -->
        <script type="x-shader/x-fragment">
            #version 300 es
            /*********
            * made by Matthias Hurrle (@atzedent)
            */
            precision highp float;
            out vec4 O;
            uniform vec2 resolution;
            uniform float time;

            #define FC gl_FragCoord.xy
            #define R resolution
            #define T time
            #define MN min(R.x,R.y)
            #define S smoothstep
            #define beat(a) pow(S(.4,.6,sin(3.1415/a*T)*.5+.5),5.)

            float rnd(vec2 p) {
              p = fract(p * vec2(12.9898, 78.233));
              p += dot(p, p + 34.56);
              return fract(p.x * p.y);
            }
            float spirals(vec2 uv) {
              float c = 0.0, d = 0.0, k = 0.35;
              for (float i = 1.; i < 8.; i++) {
                c += abs(sin(T / i) * 0.05) / length(vec2(uv.y, sin(uv.y + T * i) * k) - uv.yx);
                vec2 p = uv;
                p.x -= sin(p.y + T * i) * k;
                p.y += T * 1.5;
                p.y = mod(p.y, .5) - .25;
                d += 0.008 / length(p);
              }
              c *= abs(d);
              return c;
            }
            vec3 pattern(vec2 uv) {
              float k = 4.0 / MN;
              return sqrt(
                spirals(uv * 0.95) * vec3(
                  spirals(uv - k),
                  spirals(uv),
                  spirals(uv + k)
                )
              ) * 0.25;
            }

            void main() {
              vec3 col = vec3(0.0);
              float tt = beat(3.),
                    t  = beat(6.),
                    m  = S(1e-3, .5, 1.0 / (10.0 + 90.0 * (1.0 - tt))),
                    n  = S(1e-3, .5, 1.0 / (7.0 + 93.0 * tt));
              vec2 uv = (FC - 0.5 * R) / MN;
              if (R.x > R.y) uv = vec2(uv.y, -uv.x);
              uv *= 1.5 + sqrt(t * .8);

              vec2 p = uv * (1.0 + 0.25 * sqrt(t));
              uv -= uv * mix(.2, 1., rnd(uv)) * n;
              p  -= p  * mix(.4, .8, rnd(FC)) * m;
              col += vec3(pow(sin(p.x * 10.) * cos(p.y * 10.), 0.2)) * 0.2;
              col = max(col, pattern(uv));
              O = vec4(col, 1.0);
            }
        </script>

        <!-- GSAP-based WebGL setup -->
        <script>
            window.onload = init;
            function init() {
                let renderer, canvas;
                const dpr = Math.max(1, devicePixelRatio);

                const resize = () => {
                    const { innerWidth: width, innerHeight: height } = window;
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    if (renderer) {
                        renderer.updateScale(dpr);
                    }
                };

                const source = document.querySelector(
                    "script[type='x-shader/x-fragment']"
                ).textContent;
                canvas = document.createElement("canvas");
                document.body.innerHTML = "";
                document.body.appendChild(canvas);
                document.body.style =
                    "margin:0; touch-action:none; overflow:hidden;";
                canvas.style.width = "100%";
                canvas.style.height = "auto";
                canvas.style.userSelect = "none";

                renderer = new Renderer(canvas, dpr);
                renderer.setup();
                renderer.init();
                resize();

                if (renderer.test(source) === null) {
                    renderer.updateShader(source);
                }
                window.onresize = resize;

                const loop = (now) => {
                    renderer.render(now);
                    requestAnimationFrame(loop);
                };
                loop(0);
            }

            class Renderer {
                #vertexSrc = `#version 300 es
              precision highp float;
              in vec4 position;
              void main() {
                gl_Position = position;
              }`;

                #fragmtSrc = `#version 300 es
              precision highp float;
              out vec4 O;
              uniform float time;
              uniform vec2 resolution;
              void main() {
                vec2 uv = gl_FragCoord.xy / resolution;
                O = vec4(uv, sin(time) * 0.5 + 0.5, 1.0);
              }
              `;

                #vertices = [-1, 1, -1, -1, 1, 1, 1, -1];

                constructor(canvas, scale) {
                    this.canvas = canvas;
                    this.scale = scale;
                    this.gl = canvas.getContext("webgl2");
                    this.gl.viewport(
                        0,
                        0,
                        canvas.width * scale,
                        canvas.height * scale
                    );
                    this.shaderSource = this.#fragmtSrc;
                }
                get defaultSource() {
                    return this.#fragmtSrc;
                }
                updateShader(source) {
                    this.reset();
                    this.shaderSource = source;
                    this.setup();
                    this.init();
                }
                updateScale(scale) {
                    this.scale = scale;
                    this.gl.viewport(
                        0,
                        0,
                        this.canvas.width * scale,
                        this.canvas.height * scale
                    );
                }
                compile(shader, source) {
                    const gl = this.gl;
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        console.error(gl.getShaderInfoLog(shader));
                        this.canvas.dispatchEvent(
                            new CustomEvent("shader-error", {
                                detail: gl.getShaderInfoLog(shader),
                            })
                        );
                    }
                }
                test(source) {
                    let result = null;
                    const gl = this.gl;
                    const shader = gl.createShader(gl.FRAGMENT_SHADER);
                    gl.shaderSource(shader, source);
                    gl.compileShader(shader);
                    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                        result = gl.getShaderInfoLog(shader);
                    }
                    if (gl.getShaderParameter(shader, gl.DELETE_STATUS)) {
                        gl.deleteShader(shader);
                    }
                    return result;
                }
                reset() {
                    const { gl, program, vs, fs } = this;
                    if (
                        !program ||
                        gl.getProgramParameter(program, gl.DELETE_STATUS)
                    )
                        return;
                    if (gl.getShaderParameter(vs, gl.DELETE_STATUS)) {
                        gl.detachShader(program, vs);
                        gl.deleteShader(vs);
                    }
                    if (gl.getShaderParameter(fs, gl.DELETE_STATUS)) {
                        gl.detachShader(program, fs);
                        gl.deleteShader(fs);
                    }
                    gl.deleteProgram(program);
                }
                setup() {
                    const gl = this.gl;
                    this.vs = gl.createShader(gl.VERTEX_SHADER);
                    this.fs = gl.createShader(gl.FRAGMENT_SHADER);
                    this.compile(this.vs, this.#vertexSrc);
                    this.compile(this.fs, this.shaderSource);
                    this.program = gl.createProgram();
                    gl.attachShader(this.program, this.vs);
                    gl.attachShader(this.program, this.fs);
                    gl.linkProgram(this.program);
                    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
                        console.error(gl.getProgramInfoLog(this.program));
                    }
                }
                init() {
                    const { gl, program } = this;
                    this.buffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer);
                    gl.bufferData(
                        gl.ARRAY_BUFFER,
                        new Float32Array(this.#vertices),
                        gl.STATIC_DRAW
                    );

                    const position = gl.getAttribLocation(program, "position");
                    gl.enableVertexAttribArray(position);
                    gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);

                    program.resolution = gl.getUniformLocation(
                        program,
                        "resolution"
                    );
                    program.time = gl.getUniformLocation(program, "time");
                }
                render(now = 0) {
                    const { gl, program, buffer, canvas } = this;
                    if (
                        !program ||
                        gl.getProgramParameter(program, gl.DELETE_STATUS)
                    )
                        return;

                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);

                    gl.useProgram(program);
                    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);

                    gl.uniform2f(
                        program.resolution,
                        canvas.width,
                        canvas.height
                    );
                    gl.uniform1f(program.time, now * 1e-3);

                    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
                }
            }
        </script>
    </body>
</html>
