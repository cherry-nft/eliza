<html><head><base href="https://zombiesurvival3d.com"><title>Zombie Survival 3D (v.1.2)</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.3/howler.min.js"></script>
<style>
body, html {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
  font-family: 'Orbitron', sans-serif;
  background-color: #000;
}
#game-container {
  width: 100%;
  height: 100%;
}
#hud {
  position: absolute;
  top: 20px;
  left: 20px;
  color: #0ff;
  font-size: 24px;
  text-shadow: 0 0 10px #0ff;
  background-color: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #0ff;
  box-shadow: 0 0 20px #0ff;
}
#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 20px;
  height: 20px;
  transform: translate(-50%, -50%);
  color: #0ff;
  font-size: 32px;
  text-shadow: 0 0 10px #0ff;
  pointer-events: none;
}
#game-over, #start-screen {
  display: none;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #0ff;
  font-size: 64px;
  text-align: center;
  text-shadow: 0 0 20px #0ff;
  background-color: rgba(0, 0, 0, 0.8);
  padding: 40px;
  border-radius: 20px;
  border: 4px solid #0ff;
  box-shadow: 0 0 40px #0ff;
}
#start-screen {
  display: block;
}
button {
  font-family: 'Orbitron', sans-serif;
  font-size: 32px;
  padding: 15px 30px;
  margin-top: 30px;
  cursor: pointer;
  background-color: #0ff;
  color: #000;
  border: none;
  border-radius: 10px;
  transition: all 0.3s ease;
}
button:hover {
  background-color: #fff;
  box-shadow: 0 0 20px #fff;
}
#weapon-display {
  position: absolute;
  bottom: 30px;
  right: 30px;
  color: #0ff;
  font-size: 32px;
  text-shadow: 0 0 10px #0ff;
  background-color: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #0ff;
  box-shadow: 0 0 20px #0ff;
}
#weapon-icon {
  width: 60px;
  height: 60px;
  display: inline-block;
  margin-right: 15px;
  vertical-align: middle;
}
#weapon-info {
  display: inline-block;
  vertical-align: middle;
}
#danger-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #f00;
  font-size: 96px;
  text-shadow: 0 0 30px #f00;
  opacity: 0;
  transition: opacity 0.3s ease-in-out;
}
#fullscreen-info {
  position: absolute;
  bottom: 20px;
  left: 20px;
  color: #0ff;
  font-size: 20px;
  text-shadow: 0 0 10px #0ff;
}
#minimap {
  position: absolute;
  top: 20px;
  right: 20px;
  width: 200px;
  height: 200px;
  background-color: rgba(0, 0, 0, 0.5);
  border: 2px solid #0ff;
  border-radius: 10px;
}
#level-info {
  position: absolute;
  top: 240px;
  right: 20px;
  color: #0ff;
  font-size: 24px;
  text-shadow: 0 0 10px #0ff;
  background-color: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #0ff;
  box-shadow: 0 0 20px #0ff;
}
#error-message {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: #f00;
  font-size: 24px;
  text-align: center;
  background-color: rgba(0, 0, 0, 0.8);
  padding: 20px;
  border-radius: 10px;
  border: 2px solid #f00;
  display: none;
}
#sound-status {
  position: absolute;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  color: #0ff;
  font-size: 24px;
  text-shadow: 0 0 10px #0ff;
  background-color: rgba(0, 0, 0, 0.5);
  padding: 15px;
  border-radius: 10px;
  border: 2px solid #0ff;
  box-shadow: 0 0 20px #0ff;
}
#reload-progress {
  position: absolute;
  bottom: 100px;
  left: 50%;
  transform: translateX(-50%);
  width: 200px;
  height: 20px;
  background-color: rgba(0, 0, 0, 0.5);
  border: 2px solid #0ff;
  border-radius: 10px;
  overflow: hidden;
  display: none;
}
#reload-bar {
  width: 0%;
  height: 100%;
  background-color: #0ff;
  transition: width 0.5s linear;
}
</style>
</head>
<body>
<div id="game-container">
  <div id="hud">
    Health: <span id="health">100</span> | 
    Score: <span id="score">0</span>
  </div>
  <div id="crosshair">+</div>
  <div id="weapon-display">
    <div id="weapon-icon"></div>
    <div id="weapon-info">
      <div id="weapon-name">Pistol</div>
      <div>Ammo: <span id="ammo">âˆž</span></div>
    </div>
  </div>
  <div id="danger-indicator">!</div>
  <div id="game-over">GAME OVER<br><button onclick="startGame()">Restart</button></div>
  <div id="start-screen">
    Zombie Survival 3D (v.1.2)<br>
    <button onclick="startGame()">Start Game</button>
    <p style="font-size: 14px;">WASD: Move | Mouse: Aim | Click/Hold: Shoot | R: Reload | F: Fullscreen | Mouse Wheel: Switch Weapons | Space: Jump | M: Toggle Sound
<br><span style="font-size: 12px; color: #999;">Made by Mitikas</span></p>
  </div>
  <div id="fullscreen-info"></div>
  <canvas id="minimap"></canvas>
  <div id="level-info">Level: <span id="level">1</span></div>
  <div id="error-message"></div>
  <div id="sound-status" style="font-size: 18px; padding: 10px;">Sound: ON</div>
  <div id="reload-progress"><div id="reload-bar"></div></div>
</div>

<script>
let scene, camera, renderer, controls;
let healthDisplay, ammoDisplay, scoreDisplay, gameOverScreen, startScreen, weaponNameDisplay, weaponIconDisplay, dangerIndicator, levelDisplay, errorMessage, soundStatus, reloadProgress, reloadBar;
let health, score, zombies, level;
let moveForward, moveBackward, moveLeft, moveRight, canJump, isJumping;
let prevTime = performance.now();
const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();

const weaponList = ['pistol', 'assaultRifle'];
let currentWeaponIndex = 0;
const weapons = {
  pistol: { name: 'Pistol', ammo: Infinity, maxAmmo: Infinity, damage: 25, fireRate: 300, model: null, icon: 'ðŸ”«', sound: 'https://quicksounds.com/uploads/tracks/358395028_504475934_190200697.mp3' },
  assaultRifle: { name: 'Assault Rifle', ammo: 30, maxAmmo: 30, damage: 20, fireRate: 100, model: null, icon: 'ðŸ”«', sound: 'https://quicksounds.com/uploads/tracks/279995648_1748089229_864566279.mp3', reloadTime: 500 }
};

let zombieInterval;
let minimapContext;
let isShooting = false;
let isSoundOn = true;
let lastEmptyClipTime = 0;
let isReloading = false;

const sounds = {
  bgm: new Howl({
    src: ['https://cdn.freesound.org/previews/573/573379_5672375-lq.mp3'],
    loop: true,
    volume: 0.5,
    autoplay: true
  }),
  zombieGroan: new Howl({
    src: ['zombie_groan.mp3'],
    volume: 0.3
  }),
  reload: new Howl({
    src: ['reload.mp3']
  }),
  assaultRifleReload: new Howl({
    src: ['https://www.myinstants.com/media/sounds/reloadedd.mp3'],
    volume: 0.5
  }),
  emptyClip: new Howl({
    src: ['https://hl2sounds.ceifa.dev/hl2/sound/weapons/pistol/pistol_empty.wav'],
    volume: 0.5
  }),
  playerHurt: new Howl({
    src: ['https://hl2sounds.ceifa.dev/hl2/sound/player/pl_pain7.wav'],
    volume: 0.5
  }),
  playerDeath: new Howl({
    src: ['https://hl2sounds.ceifa.dev/hl2/sound/player/pl_fallpain1.wav'],
    volume: 0.7
  }),
  levelUp: new Howl({
    src: ['level_up.mp3']
  }),
  zombieAttack: new Howl({
    src: ['zombie_attack.mp3'],
    volume: 0.5
  }),
  jump: new Howl({
    src: ['https://quicksounds.com/uploads/tracks/1515880237_541474184_813032457.mp3'],
    volume: 0.5
  }),
  weaponSwitch: new Howl({
    src: ['weapon_switch.mp3'],
    volume: 0.5
  }),
  pistolShot: new Howl({
    src: ['https://quicksounds.com/uploads/tracks/358395028_504475934_190200697.mp3'],
    volume: 0.5
  }),
  assaultRifleShot: new Howl({
    src: ['https://quicksounds.com/uploads/tracks/279995648_1748089229_864566279.mp3'],
    volume: 0.5
  }),
  zombieDeath: new Howl({
    src: ['https://free-sound-effects.net/mp3/03/free-sound-1674933021.mp3'],
    volume: 0.5
  })
};

const SPAWN_POSITION = new THREE.Vector3(0, 1.6, 0);
const ATTACK_RANGE = 2; // Distance at which zombies can attack
const ATTACK_COOLDOWN = 1000; // Cooldown between zombie attacks in milliseconds
const ATTACK_DAMAGE = 10; // Damage dealt by zombie attacks
const JUMP_FORCE = 7; // Jump force
const GRAVITY = -14; // Gravity force
const EMPTY_CLIP_COOLDOWN = 100; // Cooldown for empty clip sound (milliseconds)

function init() {
  try {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.01);
    
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000);
    document.getElementById('game-container').appendChild(renderer.domElement);

    healthDisplay = document.getElementById('health');
    ammoDisplay = document.getElementById('ammo');
    scoreDisplay = document.getElementById('score');
    gameOverScreen = document.getElementById('game-over');
    startScreen = document.getElementById('start-screen');
    weaponNameDisplay = document.getElementById('weapon-name');
    weaponIconDisplay = document.getElementById('weapon-icon');
    dangerIndicator = document.getElementById('danger-indicator');
    levelDisplay = document.getElementById('level');
    errorMessage = document.getElementById('error-message');
    soundStatus = document.getElementById('sound-status');
    reloadProgress = document.getElementById('reload-progress');
    reloadBar = document.getElementById('reload-bar');

    minimapContext = document.getElementById('minimap').getContext('2d');

    resetGameState();

    // Player
    camera.position.copy(SPAWN_POSITION);
    controls = new THREE.PointerLockControls(camera, renderer.domElement);

    // Environment
    createEnvironment();

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    const moonLight = new THREE.DirectionalLight(0x6699ff, 0.5);
    moonLight.position.set(50, 100, 50);
    scene.add(moonLight);

    // Weapon models
    createWeaponModels();

    // Movement
    moveForward = moveBackward = moveLeft = moveRight = canJump = isJumping = false;

    document.addEventListener('keydown', onKeyDown);
    document.addEventListener('keyup', onKeyUp);
    window.addEventListener('resize', onWindowResize);
    window.addEventListener('wheel', onMouseWheel);
    document.addEventListener('mousedown', onMouseDown);
    document.addEventListener('mouseup', onMouseUp);

    updateWeaponDisplay();
    updateHUD();

    animate();
  } catch (error) {
    console.error('Error initializing game:', error);
    showErrorMessage('Failed to initialize game. Please try reloading the page.');
  }
}

function showErrorMessage(message) {
  errorMessage.textContent = message;
  errorMessage.style.display = 'block';
}

function resetGameState() {
  health = 100;
  score = 0;
  zombies = [];
  level = 1;
  currentWeaponIndex = 0;
  Object.values(weapons).forEach(weapon => {
    weapon.ammo = weapon.maxAmmo;
  });
  
  // Reset player position
  if (controls) {
    controls.getObject().position.copy(SPAWN_POSITION);
  }
  velocity.set(0, 0, 0);
  canJump = true;
  isJumping = false;

  // Kill all zombies
  clearZombies();
}

function createEnvironment() {
  // Ground with grass texture
  const textureLoader = new THREE.TextureLoader();
  const grassTexture = textureLoader.load('https://i.imgur.com/YAqeQca.jpeg');
  grassTexture.wrapS = THREE.RepeatWrapping;
  grassTexture.wrapT = THREE.RepeatWrapping;
  grassTexture.repeat.set(100, 100);
  
  const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
  const groundMaterial = new THREE.MeshLambertMaterial({ map: grassTexture });
  const ground = new THREE.Mesh(groundGeometry, groundMaterial);
  ground.rotation.x = -Math.PI / 2;
  scene.add(ground);

  // Trees with bark texture
  const treeTexture = textureLoader.load('https://i.imgur.com/UkHoBB6.jpeg');
  const treeGeometry = new THREE.ConeGeometry(2, 8, 8);
  const treeMaterial = new THREE.MeshLambertMaterial({ map: treeTexture });
  
  for (let i = 0; i < 200; i++) {
    const tree = new THREE.Mesh(treeGeometry, treeMaterial);
    tree.position.set(
      Math.random() * 200 - 100,
      4,
      Math.random() * 200 - 100
    );
    scene.add(tree);
  }

  // Rocks with texture
  const rockTexture = textureLoader.load('https://i.imgur.com/OkBgWJW.jpeg');
  const rockGeometry = new THREE.DodecahedronGeometry(1);
  const rockMaterial = new THREE.MeshLambertMaterial({ map: rockTexture });
  for (let i = 0; i < 100; i++) {
    const rock = new THREE.Mesh(rockGeometry, rockMaterial);
    rock.position.set(
      Math.random() * 200 - 100,
      0.5,
      Math.random() * 200 - 100
    );
    rock.scale.set(
      Math.random() * 2 + 1,
      Math.random() * 2 + 1,
      Math.random() * 2 + 1
    );
    scene.add(rock);
  }
}

function createWeaponModels() {
  const weaponGeometries = {
    pistol: new THREE.BoxGeometry(0.1, 0.1, 0.2),
    assaultRifle: new THREE.BoxGeometry(0.1, 0.1, 0.5)
  };

  Object.keys(weapons).forEach(weaponName => {
    const weaponMaterial = new THREE.MeshLambertMaterial({ color: 0x666666 });
    weapons[weaponName].model = new THREE.Mesh(weaponGeometries[weaponName], weaponMaterial);
    weapons[weaponName].model.position.set(0.3, -0.3, -0.5);
    weapons[weaponName].model.visible = weaponName === weaponList[currentWeaponIndex];
    camera.add(weapons[weaponName].model);
  });

  scene.add(camera);
}

function onKeyDown(event) {
  switch (event.code) {
    case 'KeyW': moveForward = true; break;
    case 'KeyS': moveBackward = true; break;
    case 'KeyA': moveLeft = true; break;
    case 'KeyD': moveRight = true; break;
    case 'KeyR': reload(); break;
    case 'KeyF': toggleFullscreen(); break;
    case 'Space': jump(); break;
    case 'KeyM': toggleSound(); break;
  }
}

function onKeyUp(event) {
  switch (event.code) {
    case 'KeyW': moveForward = false; break;
    case 'KeyS': moveBackward = false; break;
    case 'KeyA': moveLeft = false; break;
    case 'KeyD': moveRight = false; break;
  }
}

function onMouseDown(event) {
  if (controls.isLocked && event.button === 0) {
    isShooting = true;
  }
}

function onMouseUp(event) {
  if (event.button === 0) {
    isShooting = false;
  }
}

function onMouseWheel(event) {
  if (controls.isLocked) {
    if (event.deltaY < 0) {
      currentWeaponIndex = (currentWeaponIndex + 1) % weaponList.length;
    } else {
      currentWeaponIndex = (currentWeaponIndex - 1 + weaponList.length) % weaponList.length;
    }
    switchWeapon();
  }
}

function jump() {
  if (canJump) {
    velocity.y = JUMP_FORCE;
    canJump = false;
    isJumping = true;
    playSound(sounds.jump);
  }
}

function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
    });
  } else {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
}

function toggleSound() {
  isSoundOn = !isSoundOn;
  Howler.mute(!isSoundOn);
  soundStatus.textContent = `Sound: ${isSoundOn ? 'ON' : 'OFF'}`;
}

function switchWeapon() {
  Object.values(weapons).forEach(weapon => {
    weapon.model.visible = false;
  });
  
  const currentWeapon = weaponList[currentWeaponIndex];
  weapons[currentWeapon].model.visible = true;
  
  updateWeaponDisplay();
  updateHUD();
  playSound(sounds.weaponSwitch);
}

function updateWeaponDisplay() {
  const currentWeapon = weaponList[currentWeaponIndex];
  weaponNameDisplay.textContent = weapons[currentWeapon].name;
  weaponIconDisplay.textContent = weapons[currentWeapon].icon;
  ammoDisplay.textContent = weapons[currentWeapon].ammo === Infinity ? 'âˆž' : weapons[currentWeapon].ammo;
}

function createZombie() {
  const zombieGroup = new THREE.Group();

  // Body
  const bodyGeometry = new THREE.BoxGeometry(0.6, 1.2, 0.3);
  const bodyMaterial = new THREE.MeshPhongMaterial({ color: 0x2ecc71 });
  const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
  body.position.y = 0.6;
  zombieGroup.add(body);

  // Head
  const headGeometry = new THREE.SphereGeometry(0.2, 32, 32);
  const headMaterial = new THREE.MeshPhongMaterial({ color: 0x27ae60 });
  const head = new THREE.Mesh(headGeometry, headMaterial);
  head.position.y = 1.5;
  zombieGroup.add(head);

  // Eyes
  const eyeGeometry = new THREE.SphereGeometry(0.05, 32, 32);
  const eyeMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 });
  const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  leftEye.position.set(0.1, 1.55, 0.15);
  const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
  rightEye.position.set(-0.1, 1.55, 0.15);
  zombieGroup.add(leftEye, rightEye);

  // Arms
  const armGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
  const armMaterial = new THREE.MeshPhongMaterial({ color: 0x2ecc71 });
  const leftArm = new THREE.Mesh(armGeometry, armMaterial);
  leftArm.position.set(0.4, 0.9, 0);
  const rightArm = new THREE.Mesh(armGeometry, armMaterial);
  rightArm.position.set(-0.4, 0.9, 0);
  zombieGroup.add(leftArm, rightArm);

  // Legs
  const legGeometry = new THREE.BoxGeometry(0.2, 0.6, 0.2);
  const legMaterial = new THREE.MeshPhongMaterial({ color: 0x2ecc71 });
  const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
  leftLeg.position.set(0.2, 0.3, 0);
  const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
  rightLeg.position.set(-0.2, 0.3, 0);
  zombieGroup.add(leftLeg, rightLeg);

  const angle = Math.random() * Math.PI * 2;
  const radius = 20 + Math.random() * 10;
  zombieGroup.position.set(
    Math.cos(angle) * radius,
    0,
    Math.sin(angle) * radius
  );
  
  zombieGroup.userData.lastAttackTime = 0;
  
  scene.add(zombieGroup);
  zombies.push(zombieGroup);

  playSound(sounds.zombieGroan);
}

function moveZombies() {
  zombies.forEach((zombie, index) => {
    const direction = new THREE.Vector3();
    direction.subVectors(camera.position, zombie.position).normalize();
    
    // Keep zombies on the ground
    direction.y = 0;
    
    zombie.position.add(direction.multiplyScalar(0.03 + level * 0.005));
    
    // Ensure zombies stay on the ground
    zombie.position.y = 0;
    
    // Make zombie face the player
    zombie.lookAt(new THREE.Vector3(camera.position.x, 0, camera.position.z));
    
    // Animate zombie walk
    const time = Date.now() * 0.002;
    const leftArm = zombie.children[2];
    const rightArm = zombie.children[3];
    const leftLeg = zombie.children[4];
    const rightLeg = zombie.children[5];
    
    leftArm.rotation.x = Math.sin(time * 5) * 0.4;
    rightArm.rotation.x = Math.sin(time * 5 + Math.PI) * 0.4;
    leftLeg.rotation.x = Math.sin(time * 5 + Math.PI) * 0.4;
    rightLeg.rotation.x = Math.sin(time * 5) * 0.4;
    
    const distanceToPlayer = zombie.position.distanceTo(camera.position);
    
    if (distanceToPlayer < ATTACK_RANGE) {
      const currentTime = Date.now();
      if (currentTime - zombie.userData.lastAttackTime > ATTACK_COOLDOWN) {
        zombieAttack(zombie);
        zombie.userData.lastAttackTime = currentTime;
      }
    }
  });
}

function zombieAttack(zombie) {
  health -= ATTACK_DAMAGE;
  updateHUD();
  showDangerIndicator();
  playSound(sounds.zombieAttack);
  playSound(sounds.playerHurt);
  
  if (health <= 0) {
    gameOver();
  }
}

function showDangerIndicator() {
  dangerIndicator.style.opacity = '1';
  setTimeout(() => {
    dangerIndicator.style.opacity = '0';
  }, 500);
}

let lastShootTime = 0;

function shoot() {
  if (isReloading) return;

  const currentWeapon = weaponList[currentWeaponIndex];
  const currentTime = performance.now();
  if (currentTime - lastShootTime < weapons[currentWeapon].fireRate) return;

  if (weapons[currentWeapon].ammo > 0 || weapons[currentWeapon].ammo === Infinity) {
    if (weapons[currentWeapon].ammo !== Infinity) {
      weapons[currentWeapon].ammo--;
    }
    updateHUD();
    
    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(new THREE.Vector2(), camera);
    
    const intersects = raycaster.intersectObjects(zombies, true);
    if (intersects.length > 0) {
      const hitZombie = intersects[0].object.parent;
      scene.remove(hitZombie);
      zombies = zombies.filter(z => z !== hitZombie);
      score += 10;
      updateHUD();
      playSound(sounds.zombieDeath);

      if (score >= level * 100) {
        levelUp();
      }
    }

    // Weapon recoil animation
    const weapon = weapons[currentWeapon].model;
    weapon.position.z += 0.1;
    setTimeout(() => {
      weapon.position.z -= 0.1;
    }, 50);

    // Play weapon sound
    if (currentWeapon === 'pistol') {
      playSound(sounds.pistolShot);
    } else if (currentWeapon === 'assaultRifle') {
      playSound(sounds.assaultRifleShot);
    }

    lastShootTime = currentTime;
  } else {
    const currentTime = Date.now();
    if (currentTime - lastEmptyClipTime > EMPTY_CLIP_COOLDOWN) {
      playSound(sounds.emptyClip);
      lastEmptyClipTime = currentTime;
    }
  }
}

function reload() {
  const currentWeapon = weaponList[currentWeaponIndex];
  if (weapons[currentWeapon].ammo !== Infinity && !isReloading) {
    isReloading = true;
    reloadProgress.style.display = 'block';
    reloadBar.style.width = '0%';

    if (currentWeapon === 'assaultRifle') {
      playSound(sounds.assaultRifleReload);
      setTimeout(() => {
        weapons[currentWeapon].ammo = weapons[currentWeapon].maxAmmo;
        updateHUD();
        isReloading = false;
        reloadProgress.style.display = 'none';
      }, weapons[currentWeapon].reloadTime);

      // Animate reload progress bar
      reloadBar.style.transition = `width ${weapons[currentWeapon].reloadTime}ms linear`;
      setTimeout(() => {
        reloadBar.style.width = '100%';
      }, 50);
    } else {
      playSound(sounds.reload);
      weapons[currentWeapon].ammo = weapons[currentWeapon].maxAmmo;
      updateHUD();
      isReloading = false;
      reloadProgress.style.display = 'none';
    }
  }
}

function updateHUD() {
  healthDisplay.textContent = health;
  scoreDisplay.textContent = score;
  levelDisplay.textContent = level;
  const currentWeapon = weaponList[currentWeaponIndex];
  ammoDisplay.textContent = weapons[currentWeapon].ammo === Infinity ? 'âˆž' : weapons[currentWeapon].ammo;
}

function gameOver() {
  playSound(sounds.playerDeath);
  gameOverScreen.style.display = 'block';
  controls.unlock();
  clearInterval(zombieInterval);
  clearZombies();
}

function startGame() {
  try {
    resetGameState();
    clearZombies();
    Object.values(weapons).forEach(weapon => {
      weapon.model.visible = false;
    });
    weapons[weaponList[currentWeaponIndex]].model.visible = true;
    updateHUD();
    updateWeaponDisplay();
    startScreen.style.display = 'none';
    gameOverScreen.style.display = 'none';
    controls.lock();
    startZombieSpawning();
  } catch (error) {
    console.error('Error starting game:', error);
    showErrorMessage('Failed to start game. Please try again.');
  }
}

function clearZombies() {
  zombies.forEach(zombie => {
    scene.remove(zombie);
  });
  zombies = [];
}

function startZombieSpawning() {
  if (zombieInterval) {
    clearInterval(zombieInterval);
  }
  zombieInterval = setInterval(createZombie, Math.max(500, 2000 - level * 100));
}

function levelUp() {
  level++;
  health = Math.min(health + 20, 100);
  updateHUD();
  playSound(sounds.levelUp);
  startZombieSpawning();
}

function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}

function updateMinimap() {
  minimapContext.fillStyle = 'rgba(0, 0, 0, 0.5)';
  minimapContext.fillRect(0, 0, 200, 200);

  // Draw player
  minimapContext.fillStyle = '#00ffff';
  minimapContext.beginPath();
  minimapContext.arc(100, 100, 5, 0, Math.PI * 2);
  minimapContext.fill();

  // Draw zombies
  minimapContext.fillStyle = '#00ff00';
  zombies.forEach(zombie => {
    const x = 100 + (zombie.position.x - camera.position.x) / 2;
    const y = 100 + (zombie.position.z - camera.position.z) / 2;
    minimapContext.beginPath();
    minimapContext.arc(x, y, 3, 0, Math.PI * 2);
    minimapContext.fill();
  });
}

function playSound(sound) {
  if (isSoundOn) {
    sound.play();
  }
}

function animate() {
  requestAnimationFrame(animate);

  if (controls.isLocked === true) {
    const time = performance.now();
    const delta = (time - prevTime) / 1000;

    velocity.x -= velocity.x * 10.0 * delta;
    velocity.z -= velocity.z * 10.0 * delta;

    // Apply gravity
    velocity.y += GRAVITY * delta;

    direction.z = Number(moveForward) - Number(moveBackward);
    direction.x = Number(moveRight) - Number(moveLeft);
    direction.normalize();

    if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
    if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

    controls.moveRight(-velocity.x * delta);
    controls.moveForward(-velocity.z * delta);

    // Apply vertical movement (jumping)
    controls.getObject().position.y += velocity.y * delta;

    // Check if player has landed
    if (controls.getObject().position.y < SPAWN_POSITION.y) {
      velocity.y = 0;
      controls.getObject().position.y = SPAWN_POSITION.y;
      canJump = true;
      isJumping = false;
    }

    moveZombies();
    updateMinimap();

    // Handle continuous shooting for assault rifle
    if (isShooting && weaponList[currentWeaponIndex] === 'assaultRifle') {
      shoot();
    }

    prevTime = time;
  }

  renderer.render(scene, camera);
}

init();

document.addEventListener('click', () => {
  if (controls.isLocked) {
    if (weaponList[currentWeaponIndex] === 'pistol') {
      shoot();
    }
  } else {
    controls.lock();
  }
});

controls.addEventListener('lock', function() {
  gameOverScreen.style.display = 'none';
  startScreen.style.display = 'none';
});

controls.addEventListener('unlock', function() {
  if (health <= 0) {
    gameOverScreen.style.display = 'block';
  } else {
    startScreen.style.display = 'block';
  }
});
</script>

<a href="https://zombiesurvival3d.com/weapons">Advanced Weapon Customization</a> |
<a href="https://zombiesurvival3d.com/vr">VR Experience</a> |
<a href="https://zombiesurvival3d.com/multiplayer">Multiplayer Survival Mode</a>

</body></html>